* Chapter 4 Types and Declarations
  
** Types[dcl.type]
   + 在C++当中，每一个变量都是有类型的比如下面：
     #+begin_src c++
       float x;      // x is a floating-point variable
       int y = 7;    // y is an integer variable with the initial value 7
       float f(int); // f is a function taking an argument of type int and returing
                     // a floating-point number
     #+end_src
*** Fundamental Type
    C++有着非常多的数据类型，下面我们将一一介绍
    
** Booleans[dcl.bool]
   + 布尔类型只有两个值true 或者false，对于非0的值来说，都是解释成true的
   + 在算数和逻辑运算当中，bool类型都是转化成int类型的
** Character Types[dcl.char]
   + 一般来说，char类型的变量都是8bit，也就是能保存个256个字符
   + 由于只有256个字符，所以char难以做到面面俱到，一下几种想法在char类型面前都是很危险的：
     - 只有127个符号：很多系统提供了256个符号
     - 除了英文没有其他文字：欧洲系统提供了其他字母
     - alphabetic character是连续的：EBCDIC就把i和j分开了
     - C++用到的符号都包含了：很多国家的语言里面，就没有{}和[]
       #+begin_src c++
         #include <iostream>
         using namespace std;
         int main()
         {
             char c;
             std::cin>>c;
             std::cout << "the value of '" << c << "' is " << int(c) << std::endl;
             return 0;
         }
       #+end_src 
   + 上面例子中int(c)就是可以得到char c的integer值。
   + 在不同系统中char有些是有符号的，有些是没符号的，也就是说这个是implementation-defined的。
     Cpp提供两种定义：signed char，integer value是-127到127. unsigned char， integer
     value是0 到255.所幸大部分有意义的数字的ascii都在0到127之间.
   + plain char默认是unsigned的
   + 对于unicode，cpp提供了wchar_t.这个奇怪的名字来源于和c兼容。在c中wchar_t是一个typedef，
     而不是build-in的
*** Character Literals [dcl.char.lit]     
    + 所谓的character literal就是常说的character constant。也就是用单引号括起来一个字符，
      比如'c','0'等等。代码中这么写的好处是跨平台性更好
    + Wide character literals经常使用的形式是L'ab'，前面有个L，单引号里面的字符的数量和如何
      解释是因平台不同而不同的。
** Integer Types[dcl.int]
   + plain integer一般都是sigened,这点和plain char不一样.
   + unsigend integer在处理bit array方面比较适合。但是想用unsigned来代表正整数往往起不到的
     效果，因为补码这种奇怪的转换方法的存在。
*** Integer Literal
    + Integer有三种表现方式，以0开头加一个数字的是八进制，以0x开头的是十六进制，否则就是十进制
      | decimal:      |   0 |   2 |   63 |   83 |
      | octal:        |  00 |  02 |  077 | 0123 |
      | hexadeciamal: | 0x0 | 0x2 | 0x3f | 0x53 |
    + 其中十六进制代表数的情况很容易出现令人费解的情况（这也是由于补码的存在），比如0xffffffff
      在32-bit系统当中代表int的时候，表示值为-1
    + 在整数当中存在几种后缀U表示是unsigned的，L代表是long的
    + 最好不要直接使用整数，因为无端出现一个数字在代码当中是很令人费解的（也就是常说的幻数,magic
      number).这种情况想要使用const或者enumerator
** Floating-Point Type [dcl.float]
   + floating-point也分三种float, double, long double
*** Floating-Point Literals [dcl.fp.lit]
    + 一般来说，我们写一个浮点数，系统默认的会存成double格式，如果你想存成float格式，那么就加个
      后缀f或者F，比如:3.1412323f 2.23234F
    + 一般浮点数有直接表示和e表示两种:1.23 .23 0.12 1. 1.12e10 1.23e-15（注意中间不能有
      空格）
** Sizes [dcl.size]
   + int的size到底是多少，这个是平台决定的。如果想要写出能跨平台的代码那么就要尽量避免使用int的长度
     或者采取方式减小他们的影响
   + 我们之所以提供不止一种的integer，就是为了能够更好的利用硬件性能。如果你对机器的体系足够了解，那么
     就能选择好数据类型，写出更高效的程序
   + 我们可以通过<limits>的帮助，来更好的了解当前implementation的属性
     #+begin_src c++
       #include <limits>
       #include <iostream>
       using namespace std;
       
       int main()
       {
           cout << "largest float ==" << numeric_limits<float>::max()
                << ", char is signed == " << numeric_limits<char>::is_signed << endl;
       }
       
     #+end_src
** Void [dcl.void]
   + void主要就用在两个方面：
     1) 没有确定类型的指针
     2) 没有返回值的函数
        
** Enumerations [dcl.enum]
   + Enum是一种为了让代码可读性更好(防止magic number)的方法，和C语言中的宏有类似的地方,常规的用法如下,
     和宏不一样的地方是，这里重新定义了一个数据类型keyword，这样的话，编译器就能知道它的存在了。
     #+begin_src c++
       enum keyword {ASM, AUTO, BREAK}
     #+end_src
   + Enum比宏先进的地方是，它不仅仅可以让用户更好的看懂代码，也能让编译器知道它的存在，进而帮助用户发现
     代码中的错误，比如如果有下面的代码，那么编译器就会报一个warning，因为keyword并没有被全部列举
     #+begin_src c++
       void f(keyword key)
       {
           switch (key) {
           case ASM:
               // do something
               break;
           case BREAK:
               // do something
               break;
           }
       }
     #+end_src
   + Enumation的成员叫做enumerator, Enum类型的range是由绝对值最大的enumerator来决定的，MAX通常是最接近这个绝对值
     的2的幂减去一,MIN的话如果都是正数就是0，如果有复数，那么就是绝对值等于|MAX+1|的负数
     #+begin_src c++
       enum e1 {dark, light};                 //range 0:1
       enum e2 {a = 3, b = 9};                //range 0:15
       enum e3 {min = -10, max = 1000000};    //range -1048576:1048575 (1024 * 1024)
     #+end_src
   + 定义了range以后，在range里面的值对于enum来说，是defined，意义可定的，而超出range的数值，则行为未定  
     #+begin_src c++
       enum flag {x = 1, y = 2, z = 4, e = 8}; // range 0 : 15
       
       flag f1 = 5;            //type error: 5 is not type of flag
       flag f2 = flag(5);      //ok: flag(5) is of type flag and within the range of flag
       
       flag f3 = flag(z|e);    //ok: flag(12) is of type flag and within the range of flag
       flag f4 = flag(99);     //_undefined_ :99 is not within the rang of flag
       
     #+end_src
   + enum的sizeof也是平台间不同的，一个enum的sizeof是能够保存他的range的大小，而不大于sizeof(int)，比如上例中的
     sizeof(el)可能是1，也可能是4，但是绝对不可能是8
   + 一般来说enum都是转化成为integer来进行算术运算的，用户可以自己为enum定义++ <<等操作符
  
   
