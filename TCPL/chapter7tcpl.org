*  Chapter 7 Functions
** Function Declarations
   + 任何function在使用以前都必须进行声明
   + function的声明可以有参数变量，但是编译器不会去看的
*** Function Definitions
    + 程序在使用之前必须要定义，但是很多时候，我们会发现有些参数没有用到，这通常是为了以后的升级扩展
       #+begin_src c++
         void search(tabe*t, const char* key, const char*)
         {
             // no use of the third argument
         }
       #+end_src
    + 函数可以被定义为inline的，便于编译器进行优化。
    + inline关键字不影响semantics of a functio.一个inline function一样拥有unique address
*** Static Variables
    + 一般的变量都是在程序到达的时候进行一次初始化，一个function里面如果有普通变量的话，每次调用这个function
       变量就会初始化一次，然后随即函数退栈，变量销毁
    + static 变量就不一样了，因为他存储的地方就是再静态区，第一次调用function的时候，static变量初始化，function退栈
       也不会影响到static变量
** Argument Passing
   + 函数传递就分成了值传递和引用传递，也就是call-by-value, call-by-reference.一般来说call-by-reference直接调用是_有可能_
      改变参数值的，所以如果不想改变就加const引用，如果要改变，要加注释
       #+begin_src c++
         void f(const Large& arg)
         {
             // the value of "arg" cannot be changed without explict use of type conversion
         }
         
         void g(Large& arg); // assume that g() modifies arg
       #+end_src
   +  在传参过程当中有type conversion在const T&这种形式中是允许的，而反之则不允许。这种情况我们见到很多次了，其中
       原因大体讲即是const可以保证参数不变，即便引入temp variable也不会有问题。
       #+begin_src c++
         float fsqrt(const float&); // Fortran-style sqrt taking a reference argument
         
         void g(double d)
         {
             float r = fsqrt(2.0f) ;          //pass ref to temp holding 2.0f
             r = fsqrt(r);                      // pass ref to r
             r = fsqrt(d);                      // pass ref to temp holding float(d)
         }
         
         void update(float& i);
         
         void g(double d, float r)
         {
             update(2.0f);            //error:const argument
             update(r);                //pass ref to r
             update(d);               //error: type conversion required
         }
       #+end_src
*** Array Arguments
    + 如果数组作为函数参数的话， a pionter to its initial element被传递。因为传递的是T*的形式，也就意味着数组成员可以被
       改变。
    + 数组的大小一般是多加一个参数来传递的。而字符数组因为是0结尾，可以不传。
    + 我们前面说过，多维数组很容易出问题，但是通常情况下如果需要用的话，我们可以用arragy of pointer来替代比如
       #+begin_src c++
         char* day[] = {"mon", "tue", "wed", "thu", "fri", "sta", "sun"};
       #+end_src
    + 
