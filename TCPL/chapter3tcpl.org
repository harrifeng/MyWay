* Chapter 3 A Tour of the Standard Library
** Introduction
   每个系统都不可能是自己写完的，一定要有库的支持。这一章就是介绍跨平台的，每个c++编译器都实现的library: standard library
** Hello, world
   + 每个cpp都会有一个main的函数，返回一个int的返回值，告诉os自己程序完成的状态。
   + 一个带有standard output的例子如下
     #+begin_src c++
       #include <iostream>
       
       int main()
       {
           std::cout << "Hello, world\n";
       }
     #+end_src
** The Standard Library Namespace
   + Standard Library 都是定义在一个叫做std的namespace里面的，通过using namespace可以避免重复书写std
     #+begin_src c++
       #include <string>
       using namespace std;
       
       string s = "Ignorance is bliss!";        // OK, string is std::string
     #+end_src
   + 剩下的例子中都省略include 和 string
** Output
   一些output例子
   #+begin_src c++
     void f()
     {
         cout <<　10;
     }
     void g()
     {
         int i = 10;
         cout << i;
     }
     void h(int i)
     {
         cout << "the value of i is ";
         cout << i;
         cout << '\n';
     }
     // h2 is equivalent to h()
     void h2(int i)
     {
         cout << "the value of i is " << i << '\n';
     }
     void k()
     {
         cout << 'a';
         cout << 'b';
         cout << 'c';
     }
   #+end_src
** String
   + cpp提供了多种string的operation，比如连接字符串
     #+begin_src c++
       string s1 = "Hello";
       string s2 = "world";
       
       void m1()
       {
           string s3 = s1 + "," + s2 + "!\n";
           cout << s3;
       }
     #+end_src
   + 在很多应用当中add something to the end of a string是最常用的操作，这个和+=operation是一样的
     #+begin_src c++
       void m2(string& s1, string& s2)
       {
           s1 = s1 + '\n';
           s2 += '\n';
       }
     #+end_src
   + string还可以用来比较
     #+begin_src c++
       string incantation;
       
       void respond(const string& answer)
       {
           if (answer == incantation)
           {
               //perform magic
           }
           else if (answer == "yes")
           {
               //...
           }
           //..
       }
     #+end_src
   + 对子字符串的操作很常见
     #+begin_src c++
       string name = "Niels Stroustrup";
       
       void m3()
       {
           string s = name.substr(6, 10);     //s = "Stroustrup"
           name.replace(0, 5, "Nicholas");    //name becomes "Nicholas Stroustrup"
       }
     #+end_src
*** C-Style Strings
    A C-style string就是一个以\0结尾的字符数组，如果一个function要以C-style string做参数，那么我们就可以使用
    c_str()函数来转换。
    #+begin_src c++
      void f()
      {
          printf("name:%s\n", name.c_str());
      }
    #+end_src
** Input
   + 在cpp中，我们是通过>>符号来作为input operator,cin是stanard input stream
     #+begin_src c++
       void f()
       {
        int i;
        cin >>　i; // read an integer into i;
       
        double d;
        cin >> d; // read a double-precision, floating-point number into d
       }
     #+end_src
   + 下面是一个英尺和厘米的换算程序，你可以从中体会到input的使用
     #+begin_src c++
       int main(int argc, char *argv[])
       {
           const float factor = 2.54;
           float x, in, cm;
           char ch = 0;
       
           cout << "enter length:";
       
           cin >> x;
           cin >> ch;
       
           switch(ch) {
           case 'i':
               in = x;
               cm = x*factor;
               break;
           case 'c':
               in = x/factor;
               cm = x;
               break;
           default:
               in = cm = 0;
               break;
           }
       
           cout << in << "in = " << cm << "cm\n";
           return 0;
       }
     #+end_src
   + 我们如果要读入一个字符串的话（没有空格），我们可以利用string
     #+begin_src c++
       /* if you type in Eric, the response is Hello, Eric!
        * if you type in Eric Bloodaxe, the response is still
        * Hello, Eric!
        */
       int main(int argc, char *argv[])
       {
           string str;
       
           cout << "Please enter your name\n";
           cin >> str;
           cout << "Hello, " << str << "!\n";
           return 0;
       }
     #+end_src
   + 如果想要读入带空格的字符串的话，可以用getline  
     #+begin_src c++
        * if you type in Eric Bloodaxe, the response is 
        * Hello, Eric Bloodaxe!
        */
       int main(int argc, char *argv[])
       {
           string str;
       
           cout << "Please enter your name\n";
           getline(cin, str);
           cout << "Hello, " << str << "!\n";
           return 0;
       }
     #+end_src
** Containers
   A class with the main purpose of holding objects is commonly called a container.
*** Vector
    + 对于C 语言来说，对于一个pair来说struct数组是唯一的选择
      #+begin_src c++
        struct Entry
        {
            string name;
            int number;
        };
        
        Entry phone_book[10000];
        
        void print_entry(int i)
        {
            cout << phone_book[i].name << " " << phone_book[i].number << '\n';
        }
      #+end_src
    + built-in 数组是有大小限制的，所以用vector能更好的进行扩展
      #+begin_src c++
        vector<Entry> phone_book(1000);
        
        void print_entry(int i) // simple use, exactly as for array
        {
            cout << phone_book[i].name << ' ' << phone_book[i].number << "\n";
        }
        
        void add_entries(int n) // increase size by n
        {
            phone_book.resize(phone_book.size() + n);
        }
      #+end_src
    + 我们可以看到,在vector声明的时候，我们使用了括号，而不是方括号，需要你区分下面两个概念
      #+begin_src c++
        vector<Entry> book(1000);    //vector of 1000 elements
        vector<Entry> book[1000];    // 1000 empty vectors
      #+end_src
    + A Vector是一个单独的object,可以被赋值，比如
      #+begin_src c++
        void f(vector<Entry>& v)
        {
            vector<Entry> v2 = phone_book;
            v = v2;
            // ...
        }
      #+end_src
    + 赋值在这里就意味着数据的赋值，如果f()里面的赋值发生以后，v和v2各自都有了一份数据。当vector含有过多数据的时候，上面
      这种innocent-looking assignments and initialization can be /prohibitively expensive/, 当
      拷贝不可取的时候，我们可以使用/指针或者引用/
*** Range Checking
    + standard library vector竟然是没有range check的，这样一来，我们就需要定义一个叫做Vec的有range-check的容器
      #+begin_src c++
        template <typename T> class Vec: public vector<T>{
        public:
            Vec():vector<T>(){}
            Vec(int s):vector<T>(s){}
            // at() operation is a vector subscript operation that throws an exception
            // of type out_of_range if its argument is out of the vector's range
            T& operator[] (int i) {return at(i);};              //range-checked
            const T& operator[] (int i) const {return at(i);};  //range-checked
        };
      #+end_src
    + 下面就是如何捕获这个exception的例子
      #+begin_src c++
        Vec<Entry> phone_book(1000);
        
        void print_entry(int i)
        {
            cout << phone_book[i].name << " " << phone_book[i].number << '\n';
        }
        
        void f()
        {
            try {
                for (int i = 0; i < 10000; ++i)
                {
                    print_entry(i);
                }
            }
            catch (out_of_range) {
                cout << "range error \n";
            }
        }
        
        // With default exception handlers
        int main(int argc, char *argv[])
        {
            try {
                // you code
            }
            catch (out_of_range) {
                cerr << "range error \n";
            }
            catch (...) {
                cerr << "unknow exception thrown\n";
            }
            return 0;
        }
      #+end_src
*** List[tour2.list]
    + 我们会在电话表中频繁的插入和删除，这样一来，list似乎是更好的数据结构，如果我们用了list，我们更多的是要进行搜索操作
      #+begin_src c++
        list<Entry> phone_book;
        
        void print_entry(const string& s)
        {
        
            //When we don't need to modify an element of the
            //container, const_iterator is the type we want
            typedef list<Entry>::const_iterator LI;
            for (LI i = phone_book.begin(); i != phone_book.end(); ++i)
            {
                Entry& e = *i;      //reference used as shorthand
                if (s == e.name)
                    cout << e.name << ' ' << e.number << '\n';
            }
        }
        
        //If we want to change the element, use plain iterator
        void add_entry(Entry& e, list<Entry>::iterator i)
        {
            phone_book.push_front(e);     //add at beginning
            phone_book.push_back(e);      //add at end
            phone_book.insert(i, e);      //add before the element 'i' refers to
        }
      #+end_src
*** Map[tour2.map]
    + 其实对于一个pair来说（name, number)，用list也不是最好的手段，因为线性查找的效率很低，有一些其他的数据结构，支持插入
      删除和根据value来进行查找，比如map，在很多情况下，map也被称作associative array 或者dictionary
    + map都是按照他第一个type来进行索引(叫做key),并且返回他的第二个type（叫做value）
      #+begin_src c++
        map<string, int> phone_book
        
        void print_entry(const string& s)
        {
            // if no match was found for the key s, a default value
            // is returned from the phone_book
            if (int i = phone_book[s])
                cout << s << ' ' << i << '\n';
        }
      #+end_src
*** Standard Containers[tou2.stdcontainer]
    + map, list, vector 都可以用来存储phone book，各有优劣：申请vector很廉价，但是插入删除很耗时。list特点和vector相反
      map大体和list相似，但是在通过key查找value上面，作了优化
    + 下面就是所有的standard container，他们都有很多相似的特点，比如push_back()这种函数在很多容器中都可以使用
        |--------------------+---------------------------------------------|
        | vector<T>          | A variable-sized vector                     |
        | list<T>            | A doubly-linked list                        |
        | queue<T>           | A queue                                     |
        | stack<T>           | A stack                                     |
        | deque<T>           | A double-ended queue                        |
        | priority_queue<T>  | A queue dorted by value                     |
        | set<T>             | A set                                       |
        | multiset<T>        | A set in which a value can occur many times |
        | map<key, val>      | An associative array                        |
        | multimap<key, val> | A map in which a key can occur many times   |
** Algorithms
    + 对于一个数据来说，仅仅存放是没有意义的，我们还要添加删除和搜索，比如下面的代码就是用来排序vector并且拷贝到list
      #+begin_src c++
        void f(vector<Entry>& ve, list<Entry>& le)
        {
            sort(ve.begin(), ve.end());
            unique_copy(ve.begin(), ve.end(), le.begin());
        }
      #+end_src
    + 上面的操作是会覆盖list里面的数据的，如果我们不想覆盖，而是在container后面添加排序好的数字，我们可以用back_inserter
      #+begin_src c++
        void f(vector<Entry>& ve, list<Entry>& le)
        {
            sort(ve.begin(), ve.end());
            unique_copy(ve.begin(), ve.end(), back_inserter(le));
        }
      #+end_src
    + 下面是back_inserter用法易出错的地方
      #+begin_src c++
        void f(vector<Entry>& ve, list<Entry>& le)
        {
            copy(ve.begin(), ve.end(), le);       //error: le not an iterator
            copy(ve.begin(), ve.end(), le.end()); //bad:writes beyond the end
            copy(ve.begin(), ve.end(), le.begin()); //overwrite elements
        }
      #+end_src
*** Use of Iterator[tour2.iteruse]
    + 当你遇到container的时候，一些iterator会适合你引用，比如begin() 和 end(), 很多的algorithm 会返回iterator的，比如
      find，比如下面在一个字符串中寻找某个字符出现的次数.
      #+begin_src c++
        int count(const string& s, char c)
        {
            string::const_iterator i = find(s.begin(), s.end(), c);
            int n = 0;
            while (i != s.end()){
                ++n;
                i = find(i+1, s.end(), c);
            }
            return n;
        }
      #+end_src
    + 同样我们可以写一个摸板的find函数如下
      #+begin_src c++
        template<class C, class T>int count(const C&v, T val)
        {
            typename C::const_iterator i = find(v.begin(), v.end(), val);
            int n = 0;
            while (i != v.end()){
                ++n;
                ++i;
                i = find(i, v.end(), val);
            }
            return n;
        }
      #+end_src
    + 
