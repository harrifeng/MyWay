* Chapter 3: Resource Management
  + Resource是申请了需要归还系统的，最常见的就是dynamically allocated memory,其他还有
    比如file descriptor, mutex lock,database connection, network socket等
** Item 13: Use objects to manage resources
   + 我们知道要获取resource，就一定要对它进行释放，传统的方法是在函数开始申请，在函数结束
     的地方进行释放
     #+begin_src c++
       void f()
       {
           Investment *pInv = createInvestment(); // call factory
           //....  use pInv
           delete pInv;                           // release object
       }
     #+end_src
   + 上述方法的缺点是在"use pInv"的代码当中可能包含return，或其他特殊情况，导致最终不能
     到达"delete pInv"那一行。
   + 为了保证pInv一定会被释放掉，我们要把resource放到一个object里面，这个object退出作
     用域的时候，会自动在dtor里面释放资源,这种使用方法被称作Resrouce Acquisition Is
     Initialization(RAII).因为获取resource和初始化resource-managing object通常是
     一行代码而得名.
   + 在c++中，可以利用auto_ptr来完成自动释放资源的工作，在离开作用域的时候，auto_ptr里
     面的指针会被自动释放掉
     #+begin_src c++
       void f()
       {
           std::auto_ptr<Investment> pInv(createInvestment());
           // use as before;
       }   // automatically delete via auto_ptr's dtor
     #+end_src
   + auto_ptr的一大缺点，就是复制的时候，和正常的复制行为是不同的:复制一个auto_ptr的话
     就把它设置成Null了:产生这种奇怪behavior的原因是auto_ptr是自动调用delete，所以为
     了防止野指针的产生，不得已只能有一个指针指向同一个object
     #+begin_src c++
       //pInv1 points to the object returned from
       //createInvestment
       std::auto_ptr<Investment> pInv1(createInvestment());
       
       //pInv2 now points to the object,
       //pInv1 is now null
       std::auto_ptr<Investment> pInv2(pInv1);
       
       //now pInv1 points to the object,
       //pInv2 is null
       pInv1 = pInv2;
     #+end_src
   + 能够有正常复制behavior的智能指针是shared_ptr
     #+begin_src c++
       void f()
       {
           //pInv1 points to the object
           std::tr1::shared_ptr<Investment>
           pInv1(createInvestment());
       
           //both pInv1 and pInv2 point to the same object
           std::tr1::shared_ptr<Investment> pInv2(pInv1H);
       
           pInv1 = pIv2;
       } // both pInv1 and pInv2 are released.
     #+end_src
   + 无论是auto_ptr还是shared_ptr，在删除的时候，都是使用delete，而非delete[],所以
     智能指针和动态分配的数组配合是不正确而且非常危险的。
** Item 14:Think carefully about copying behavior in resource-managing classes
   + Item 13 介绍了auto_ptr和shared_ptr，它们是系统提供的resource-manage class, 但是
     它们只能对付dynamic allocated 的指针。如果遇到非dynamic allocated指针的情况下，要
     自己动手写resource-managing class, Item14介绍的就是resource在离开作用域的时候，不
     是delete resource，而是unlock resource。
   + 比如我们实现一个Lock的resource-managing类，在类的ctor里面调用lock(),在类的dtor里面
     调用unlock()
     #+begin_src c++
       class Lock {
       public:
           explicit Lock(Mutex *pm) : mutexPtr(pm) {
               lock(mutexPtr);      //acquire resource
           }
       
           ~Lock() {
           unlock(mutexPtr);        //release resource
           }
       private:
           Mutex *mutexPtr; 
       };
     #+end_src
   + 如果不涉及到copy，那么resource-managing class并不难写，但如果要copy object呢，我们
     通常有如下的几种处理方法
     - 禁止复制:比如我们可以private 继承 Uncopyable类
     - 实实在在的复制一份:这种复制是一种"深拷贝":不仅仅拷贝指针，还要拷贝对应的内存。When a
       string object is copied, a copy is mad of both the pointer and the memory
       it points to.
     - 改变resource的所有权:也就是auto_ptr所采用的，拷贝就转移所有权的方法,只能有一个指针同
       时指向同一个resource
     - 对resource引用进行计数:也就是shared_ptr所采用的方法，一般来说，只要让自己的data
       member设计成shared_ptr的形式就行了，这个mutex的例子比较特殊，我们退出作用域的时候
       并不是销毁指针，而是unlock，这个时候，就要在shared_ptr初始化的时候，加上一个deleter
       的函数指针变量，来告诉编译器，当离开作用域的时候如何处理resource
       #+begin_src c++
         void lock(Mutex *pm); // lock mutex pointed to by pm
         void unlock(Mutex *pm); // unlock the mutex
         
         class Lock {
         public:
             //mutexPtr is given two para when initialized
             //second is function pointer for deleter
             explicit Lock(Mutex *pm) : mutexPtr(pm, unlock) {
                 lock(mutexPtr.get());
             }
         private:
             std::tr1::shared_ptr<Mutex> mutexPtr;
         };
       #+end_src
** Item 15: Provide access to raw resources in resource-managing classes
