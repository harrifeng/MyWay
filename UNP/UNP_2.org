* Chapter 2: The Transport Layer: TCP, UDP, and SCTP
** Introduction:
** The Big Picture
   | IPv4   | 也就是我们常说的IP 协议，使用32bit地址为TCP, UDP， SCTP, 
   |        | 提供packet delivery 服务                                 
   | IPv6   | 替代IPv4而生，128bit的地址                              
   | TCP    | 可依赖的全双工协议，使用IPv4或者IPv6                   
   | UDP    | TCP的不可靠版本                                         
   | SCTP   | 可依赖的全双工的association                             
   | ICMP   | 处理错误和控制信息的协议                                
   | IGMP   | 处理多播的协议                                    
   | ARP    | IPv4 地址->硬件地址                                
   | RARP   | 硬件地址->IPv4 地址                                
   | ICMPv6 | 集合了ICMPv4，IGMP，ARP的功能                    
   | BPF    | BSD packet filter                                        
   | DLPI   | Datalink provider interface                              
** User Datagram Protocol (UDP)
   + UDP是一个简单的运输层协议，application层将信息写到UDP socket里面，然后再包装成
     UDP datagram，然后再放到下一层，但是不保证UDP datagram最终能传输到对方，传输的
     次序也不能保证，甚至不能保证只传输一次。
   + UDP datagram是有长度信息的，而我们知道TCP是一个byte-stream protocol，没有任何
     的边界信息，这个也是两者的重要不同
   + UDP的client和server之间的关系也是非长期的:比如一个client可以从一个socket里面发
     送一个datagram给一个server，然后不换socket，从同一个socket里面发送不同的datagram
     给另外一个server。server也一样，可以一个socket服务多个client
** Transmission Control Protocol (TCP)
   + TCP提供的是一种server和client之间的connection,这个connection使用之前要建立，使用
     之后要关闭
   + TCP同时提供可靠性，当TCP向另一端传递数据的时候，它同时还是要求对数据的确认的，
     如果某段数据的确认没有收到，那么，间隔一段时间TCP会再次发送这段数据的，直到多
     次以后，最终放弃
     - 我们说TCP是可靠的连接，但是不能保证100%传输成功，比如如果重传了很多遍，还是没有
       成功，那么TCP会选择放弃。
   + TCP含有计算RTT(round-trip time)的算法，所以TCP直到，多久等到acknoledge正常。RTT
     的数值是不停在计算的，因为受网络的影响，数值总在变化
   + TCP还会把所有发出的信息排序，以防止先传的后到(由于网络影响),和重传等造成的影响
     - UDP不能提供任何的可靠性:确认，对数据编号，RTT, 超时重传，都不支持
     - 先传后到和重发都会在UDP中发生，UDP要自己处理这些情况
   + TCP提供了流量控制:接受者时时刻刻都在提醒发送者，我想要接受的数据数目:这个由
     advertised window来保证。advertised windows一般就是received buffer的大小，也会
     动态调整
     - UDP就没有任何流量控制
   + TCP连接是全双工的，也就说两个方向都可以同时收和发。也就是说两个方向的sequence
     和window size信息都要保留
     - UDP也可以是全双工的
** Stream Control Transmission Protocol (SCTP)
   + TCP提供的是connection，而SCTP提供的确是association: Association提供的是两个system
     之间的联系，不一定局限在两个address
   + 和TCP不同的是，SCTP提供的是message-oriented的信息。发送的长度信息也会发送给接受者
   + SCTP也是分多个stream传输的，但不同的是，任何其中一个stream的丢失，不会影响到剩下
     信息的传输。这点和TCP不一样，TCP一定要等到丢失的数据找到，否则这会block其他数据
     的传输
   + SCTP还有一个multhoming的特性，就是说一个SCTP endpoint拥有多个IP address.
     - TCP也可以得到同样的健壮性，但是是通过routing protocol
** TCP Connection Establishment and Termination
*** Three-Way Handshake
    + TCP建立连接的步骤如下:
      1) Server必须准备接受一个connection，通常的过程是分别调用socket, bind, listen这
         三步称作passive open
      2) client通过调用connect来启动active open. connect会发送一个SYN告诉server当前client
         的initial sequence number(假设数字为X). SYN里面没有数据只有IP header, TCP header，TCP option
      3) Server必须ACK(X+1) client的SYN X,并且发送自己的SYN Y。 这个SYN和ACK在一个segment里面发送过去
      4) client必须ACK(Y+1) server的SYN
*** TCP Options
    SYN里面通常都有TCP option，常用的如下
    + MSS option: TCP 用这个option来声明自己的maximum segment size，也就是每个TCP segment最
      大我可以接受的数字。
    + Window scale option: 一个TCP可以告知(advertise)其他TCP自己的最大窗口值是65535,这是因为
      在TCP header里面，这是个16bits数字，但是现在通过一个14bit的option，我们可以声明最大
      (65535 * pow(2, 10))
      - 只有在发送放SYN中含有这个option，返回方的SYN中同样有个额这个option的时候，scale才
        能起效，不过这个规定没有在实现中予以保证
    + Timestamp option: 对于防止可能的数据损坏很有作用。
*** TCP Connection Termination
    + 建立连接是三步，而且结束连接是四步
      1) 首先，一方提出close，这个叫做active close. close会发送一个FIN, 表示它发送完了
      2) 然后接受到FIN的一方，就是passive close了。收到的这个FIN会被TCP接受，然后作为end-of
         -file传给application，因为收到这个FIN也就意味着在对方那里啥也接收不到了
      3) 马上，或者过一段时间，刚才收到FIN的那一端，也会close its socket，这个close也会像
         反方向发送一个FIN
      4) active close这一方收到这个FIN，并且ACK就代表整个关闭TCP过程接受
    + 在第2，3步骤之间，就是passive close传数据给active close,我们叫做half-close
    + 如果是程序结束的话exit()函数也会发送FIN
** TIME_WAIT State
   + 当实施active close的用户无论如何，最后都会进入这个状态，这个状态的时间是2MSL(Maximum
     segment lifetime)
   + MSL是一个IP datagram可以在网络上存活的最大时间，一般来说是2分钟。
   + 设计TIME_WAIT是为了如下两个方面:
     1) 为了保证全双工的正常结束:比如从client的角度出发，发送完最后一个ACK就到TIME_WAIT状态
        了。但是有可能最后一个ACK server没有收到，它就会认为自己的FIN client没有收到，于是会
        重发FIN.这也就是为什么实施active close的一方是最终TIME_WAIT的一方了，因为它的最后的
        ACK可能会丢失
     2) 为了让老的重复的segment在网络上消失:比如我们用12.106.32.254:1500和206.168.112.219:21
        这两对地址创建了一个连接，关闭以后，我们用同样的一对地址再次创建了连接。如果没有
        2MSL那么很可能上次连接的信息会被重复的接收。(因为reply的存在，一个IP datagram最多
        存在的时间无限接近于2MSL)
   + 
