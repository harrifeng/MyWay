* 01 背包问题
** 题目:
   + 有N件物品和一个容量为V的背包，第i见物品的容量是c[i],价值是w[i], 求解将哪些
     物品放入背包可使得价值总和最大
** 基本思路:
   + 最基本的背包问题，每种物品又且仅有一件，可以选择放或者不放，每一个动态规划
     问题都一个状态转移方程，对应于这个问题的状态转移方程为:
     #+begin_src c
       f[i][v] = max{f[i - 1][v], f[i - 1][v - c[i]] + w[i]}
     #+end_src
   + 解释一下这个方程，"将前i件物品放入容量为v的背包中"这个子问题，若只考虑第i件
     物品的策略(放或者不放),那么就可以转化为一个只牵涉前i-1件物品的问题:
     - 如果不放第i件物品，那么问题就转化为"前i-1件物品放入容量为v的包中"
     - 如果放第i件物品，那么问题就转化为"前i-1件物品放入到容量为v-c[i]的包中，然
       后再放入物品i
** 优化空间复杂度
   + 从上面的分析，我们可以看到，动态规划问题，和递归问题有相似的地方, 如果最简
     单的思路考虑的话，就是一个i = 1到N的循环，循环体内计算f[i][v],当算到最后的
     时候f[N][v]就是我们想要的结果，所以从更抽象的角度看，每次循环体内都是只处理
     一个物品，它的费用为cost，价值为weight
     #+begin_src c++
       for (int i = 1; i <= N; i++) {
           ZeroOnePack(c[i], w[i]);
       }
       void ZeroOnePack(int cost, int weight)
       {
           for (int v = Vmax; v>= 0; v--) {
               f[v] = MaxofTwo(f[v], f[v - cost] + weight);
           }
       }
     #+end_src
     - 在函数ZeroOnePack中，对于for循环的理解，至关重要:v从Vmax到0，也就是背包的
       容量开始，到0，求了一系列的从f[cost]到f[v], 这个地方不容易理解的是:"为什
       么从大到小进行计算"，因为感觉递推应该是先有小的，才有大的。
     - 首先，先有小的后有大的，是最外面的i=1到N的循环来保证的，ZeroOnePack这个函
       数是对数据的一次更新，数据的先后性是靠其他部分完成的。
     - 采用从大到小的方式来实现ZeroOnePack，根本原因，是我们使用了一维数组，看下
       面这句代码
     - 这句代码中第一个f[v]代表我们原始状态方程的f[i][v], 第二个f[v], f[v -
       cost]就代表了我们原始状态方程的f[i-1][v]和f[i-1][v-c[i].所以一定要最大的
       在开始，才能有这种效果
** 初始化的细节问题
   + 我们这个问题其实是讨论的背包里面"尽量装",并没有强制要求"恰好装满",我们这个
     例子中对于变量的初始化是放在全局变量，使其初始化为0，如果是"恰好装满"的情况，
     初始化的时候就要把变量初始化为负的无穷大。
   + 我们可以这样理解，如果"尽量装"呢，0也算是"能交差"，也就是说至少存在一个合法
     的解。如果是"恰好装满",0就不是"能交差"的结果了，也就是说，可能出现没有解的
     情况。
* 完全背包问题
** 题目
   + 有N种物品和一个容量为v的背包，每种物品都有无限件可用。第i种物品的费用是
     c[i], 价值是w[i].求解哪些物品放入背包可使得物品的费用总和不超过背包的容量，
     且价值总和最大。
** 基本思路
   + 完全背包问题和01背包问题其实非常像，所不同的是，每种物品可以取多件。和01背
     包的差别就是，我现在是0123...背包问题。按照01背包的思路，我们有如下的状态转
     移方程:
     #+begin_src c
       f[i][v] = max{f[i-1][v-k*c[i]] + k*w[i] | 0 <= k*c[i] <= v}    
     #+end_src
   + 我们知道，01背包的复杂度是O(VN), 这里的复杂度应该为O(V*Σ(V/c[i]), 因为要遍
     历各种情况






 
