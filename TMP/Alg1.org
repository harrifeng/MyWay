* 01 背包问题
** 题目:
   + 有N件物品和一个容量为V的背包，第i见物品的容量是c[i],价值是w[i], 求解将哪些
     物品放入背包可使得价值总和最大
** 基本思路:
   + 最基本的背包问题，每种物品又且仅有一件，可以选择放或者不放，每一个动态规划
     问题都一个状态转移方程，对应于这个问题的状态转移方程为:
     #+begin_src c
       f[i][v] = max{f[i - 1][v], f[i - 1][v - c[i]] + w[i]}
     #+end_src
   + 解释一下这个方程，"将前i件物品放入容量为v的背包中"这个子问题，若只考虑第i件
     物品的策略(放或者不放),那么就可以转化为一个只牵涉前i-1件物品的问题:
     - 如果不放第i件物品，那么问题就转化为"前i-1件物品放入容量为v的包中"
     - 如果放第i件物品，那么问题就转化为"前i-1件物品放入到容量为v-c[i]的包中，然
       后再放入物品i
** 优化空间复杂度
   + 从上面的分析，我们可以看到，动态规划问题，和递归问题有相似的地方, 如果最简
     单的思路考虑的话，就是一个i = 1到N的循环，循环体内计算f[i][v],当算到最后的
     时候f[N][v]就是我们想要的结果，所以从更抽象的角度看，每次循环体内都是只处理
     一个物品，它的费用为cost，价值为weight
     #+begin_src c++
       for (int i = 1; i <= N; i++) {
           ZeroOnePack(c[i], w[i]);
       }
       void ZeroOnePack(int cost, int weight)
       {
           for (int v = Vmax; v>= 0; v--) {
               f[v] = MaxofTwo(f[v], f[v - cost] + weight);
           }
       }
     #+end_src
     - 在函数ZeroOnePack中，对于for循环的理解，至关重要:v从Vmax到0，也就是背包的
       容量开始，到0，求了一系列的从f[cost]到f[v], 这个地方不容易理解的是:"为什
       么从大到小进行计算"，因为感觉递推应该是先有小的，才有大的。
     - 首先，先有小的后有大的，是最外面的i=1到N的循环来保证的，ZeroOnePack这个函
       数是对数据的一次更新，数据的先后性是靠其他部分完成的。
     - 采用从大到小的方式来实现ZeroOnePack，根本原因，是我们使用了一维数组，看下
       面这句代码
     - 这句代码中第一个f[v]代表我们原始状态方程的f[i][v], 第二个f[v], f[v -
       cost]就代表了我们原始状态方程的f[i-1][v]和f[i-1][v-c[i].所以一定要最大的
       在开始，才能有这种效果
** 初始化的细节问题
   + 我们这个问题其实是讨论的背包里面"尽量装",并没有强制要求"恰好装满",我们这个
     例子中对于变量的初始化是放在全局变量，使其初始化为0，如果是"恰好装满"的情况，
     初始化的时候就要把变量初始化为负的无穷大。
   + 我们可以这样理解，如果"尽量装"呢，0也算是"能交差"，也就是说至少存在一个合法
     的解。如果是"恰好装满",0就不是"能交差"的结果了，也就是说，可能出现没有解的
     情况。
* 完全背包问题
** 题目
   + 有N种物品和一个容量为v的背包，每种物品都有无限件可用。第i种物品的费用是
     c[i], 价值是w[i].求解哪些物品放入背包可使得物品的费用总和不超过背包的容量，
     且价值总和最大。
** 基本思路
   + 完全背包问题和01背包问题其实非常像，所不同的是，每种物品可以取多件。和01背
     包的差别就是，我现在是0123...背包问题。按照01背包的思路，我们有如下的状态转
     移方程:
     #+begin_src c
       f[i][v] = max{f[i-1][v-k*c[i]] + k*w[i] | 0 <= k*c[i] <= v}    
     #+end_src
   + 我们知道，01背包的复杂度是O(VN), 这里的复杂度应该为O(V*Σ(V/c[i]), 因为要遍
     历各种情况,但是显然，这个解法需要进一步的优化
** 一个简单的有效的优化
   + 从常识出发，我们首先想到的，是去掉那种"性价比不高"的物品，比如c[i] <= c[j]
     并且w[i]>w[j],那么j显然性价比小于i，在任何情况下，选择i都比j更加合适
   + 当然了，还可以简单的把费用大于V的物品去掉，不过无论如何，这些优化都是很有限
     的，没有从根本上提高算法的效率
** 转化为01背包问题求解
   + 我们知道，虽然每件物品的数目不限，但是最多最多每件物品也就是V/c[i],于是我们
     就把第i件物品分成了V/c[i]件费用和价值都不变的物品。
   + 如果细心大家就会发现，这个和基本思路在复杂度方面，完全没有区别，都是
     O(V*Σ(V/c[i]),但是思考起来却清晰了很多
** O(VN)的算法
   + 最叹为观止的是，我们简单的将01背包中的循环从v=V...0改成V=0...V,就得到另一个
     复杂度为O(VN)的算法
     #+begin_src c++
       for (int i = 1; i <= N; i++) {
           TotalPack(c[i], w[i]);
       }
       void TotalPack(int cost, int weight)
       {
           for (int v = 0; v<= Vmax; v--) {
               f[v] = MaxofTwo(f[v], f[v - cost] + weight);
           }
       }
     #+end_src
   + 虽然是简简单单的一个循环顺序的改变，但是意义却改变巨大，因为我们是一维数组
     来表示二维的动态转换方程，所以ZeroOnePack里面的第一个f[v]代表f[i][v],而第二
     个f[v]就代表f[i-1][v], 正是因为倒序，所以当对于i来说进行选择的时候，我们不
     可能去再次选择i这件物品，因为我来选择i就说明原来没放置过i，我这次来决定是放
     i还是不放i
   + 在TotalPack里面，我们采用了正序，那么第一个f[v]代表f[i][v],第二个f[v]也可以
     和第一个的意思相同，因为我们选择过一次物品i，我们还可以第二次选择物品i。
* 多重背包问题
** 题目:
   + 有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件的费用是c[i],
     价值是w[i],求解将哪些物品装入背包可使得这些物品的费用总和不超过背包容量，且
     价值总和最大
** 基本算法:
   + 基本算法还是如下的状态转移方程，只是对于第i种物品，有n[i]+1一种策略，最后这
     个状态转移方程的复杂度是O(V*Σn[i])。
     #+begin_src c
       f[i][v] = max{f[i-1][v-k*c[i]] + k*w[i] | 0<=k<=n[i]
     #+end_src
** 转化为01背包问题
   + 最简单朴素的转换成01背包的方法，就是把第i中物品看成是n[i]个物品，很容易得到
     复杂度还是O(V*Σn[i])
   + 一个可以明显降低复杂度的优化，是把n[i]分成一系列数字，这些数字的组合能够保
     证从1到n[i]都能有，比如13，我们分成1,2,4,6.那么就是1到13可以由这四个数字任
     意组成。
   + 得到这些个数字的方式是2^0 + 2^1 + 2^2+ (13 - 2^3 + 1)， 我们可以看到每次的
     物品从n[i]减少到logn[i],相应的复杂度也会减小到O(V*Σlog n[i])
** O(VN)的算法
   + 多重背包问题同样有O(VN)的算法，是由单调队列优化的DP得来的，比较难，我们以后
     有机会讨论





 
