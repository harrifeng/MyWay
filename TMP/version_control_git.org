* Chapter 1: Introduction
  + Background:
    主要就是介绍凡是一切可以保存不同版本信息的工具都叫Version Control System
  + The Birth of Git:
    Git的诞生是因为Linux内核开发开源软件,和如下几个特殊的特性的需要,而产生的:
    - 需要支持分布式开发:
      新的VCS必须能够让不同的私有代码库在不用和主代码库进行频繁同步的情况下独自
      开发
    - 可以能够应付数以万计的开发者:
    - 能够快速有效的进行运行:
    - 保证数据的完整性:
      使用了SHAQ 算法来校验
    - 为每一次提交强制保留注释
    - 某些代码必须不能改动
    - 操作必须有原子性
    - 必须而且要鼓励分支开发(branched development)
    - 每一个开发者的本地信息足够丰富,可以在不查询中心服务器的情况下,了解自己的版
      本历史
    - 内部设计要简洁
  + Precedents
    我们也有必要来了解一下VCS的历史:
    1) 第一个成功的VCS是SCCS, 这个软件发明了repository这个词,用来表示中心代码库,
       同时提供了一直简单的锁文件的方法:如果一个用户想要运行代码,那么就要保证代
       码是unlock的状态,然后把代码check out出来并且加锁.等编辑完之后再check in并
       且unlock,简言之就是一旦要check out就一定保证在server端加锁,这样其他人就不
       能使用这些代码了
    2) 1986年诞生的CVS,更改了SCCS每次一个文件只能有一个人更改的策略,转而给一个文
       件的不同用户都有写的权限,然后当两个用户写完时,再进行merge,如果两者改动了
       同一行,那么要手动进行merge,否则CVS可以自动为用户进行merge
    3) CVS自身的各种问题,导致了新一代VCS的诞生,那就是SVN, SVN对CVS系统的贡献是:
       能够自动提交代码并且对分支支持的更好
    4) 第四代的VCS就是以BitKeeper和Mercurial为代表了,他们的更改非常激进:他们摒弃
       了中央代码库的设计,让代码进行分布式存储,每一个用户都有一份可分享的拷贝.Git正
       是继承了这种P2P的存储方式
    5) Git又从Mercurial那里学到了利用文件内容来进行唯一判定文件的方法
  + Time Line
  + What's in a Name?
* Chapter 2: Instlling Git
  + Using Linux Binary Distributions:
    在Debian/Ubuntu上面有:
    - git-core: git主要的文件
    - git-arch, git-cvs, git-svn: 从其他VCS里面导入到git中需要的软件
    - git-gui, gitk, gitweb:是三种gui或者web的显示方式
    - git-email:用邮件发送Git patch
    - git-daemon-run: 通过匿名的下载来分享你的代码库(github上面下载zip包应该就是
      利用了这个程序)
* Chapter 3: Getting Started
** The Git Command Line
    + git中有很多的option, 这些option有些是为git服务的(比如下面的--version),有些
      是为subcommand服务的(比如下面的--amend)
      #+begin_src sh 
        $ git --version
        git version 1.6.0
        
        $ git commit --amend
      #+end_src
    + git命令同时兼容长的和短的option,比如
      #+begin_src sh 
        $ git commit -m "Fixed a typo."
        $ git commit --message="Fixed a type"
      #+end_src
    + 上面的message 这个长参数使用了"--"来隔开,在git里面,为了突出filename,也经常
      用到"--":下面第一个例子里面tools/Makefile就是一个文件. 第一个main.c为一个
      tag name,而第二个main.c为一个filename
      #+begin_src sh 
        $git diff -w master origin -- tools/Makefile
        
        #Checkout the tag named "main.c"
        $ git checkout main.c
        
        #Checkout the file named "main.c"
        $ git checkout -- main.c
      #+end_src
** Quick Introduction to Using Git
*** Creating an Initial Repository
    + 我们建立一个文件夹,然后把他初始化为git repository:
      #+begin_src sh 
        $ mkdir ~/public_html
        $ cd ~/public_html
        $ echo 'My website is alive!' > index.html
        # turn public_html into a Git repository
        $ git init
      #+end_src
    + 我们可以发现git repository的过程,并不需要当前文件夹为空,而git init的结果就
      是在public_html下面建立了一个.git的隐藏文件夹,即便在public_html文件夹里面
      再建立其他文件夹也不会产生其他.git文件夹了,这个是Git又和其他VCS不一样的地
      方,它所有的信息都存在了这一个文件夹里面.
*** Adding a File to Your Repository
    + 我们把一个文件加入到代码库的方法如下, 然后查看当前repository信息
      #+begin_src sh 
        $ git add index.html
        $ git status
        # On branch master
        #
        # Initial commit
        #
        # Changes to be committed:
        #   (use "git rm --cached <file>..." to unstage)
        #
        #   new file:   index.html
        #
      #+end_src
    + 如果真正的想把文件提交到代码库,需要commit:
      #+begin_src sh 
        $ git commit -m "Initial contents of public_html" \
            --author="Haoran Feng <harrifeng@gmail.com>"
        [master (root-commit) ed24602] Initial contents of public_html
         Author: Haoran Feng <harrifeng@gmail.com>
         1 files changed, 1 insertions(+), 0 deletions(-)
         create mode 100644 index.html
      #+end_src
    + 之后再看status,就发现没有需要提交的代码了
    + 之所以要把代码提交分成add和commit两个阶段,我想是因为commit一定要写注释,而
      且多次的add, remove等操作都是不需要的.一系列有意义的add remove change才需
      要写一次注释,从而进行一次commit. 进而也不至于使得代码库过于凌乱
      #+begin_src sh 
        $ git status
        # On branch master
        nothing to commit (working directory clean)
      #+end_src
 
        








      
      

*** Configuring the Commit Author
    + 为了不每次都设置用户名和邮箱名,我们可以在开始把这些基本信息都设置好:
      #+begin_src sh 
        $ git config user.name "Haoran Feng"
        $ git config user.email "harrifeng@gmail.com"
      #+end_src
*** Making Another Commit
    + 我们可以对index.html进行一次更改,然后进行提交,如此一来,这个文件就有两个版
      本了
*** Viewing Your Commits
    + 我们可以通过git log来取出历次commit的信息
      #+begin_src sh 
        $ git log
        
        commit 3fa3f7afbc62195565a8a70649fe02dbe2ce3061
        Author: Harri Feng <fenghaoran18@gmail.com>
        Date:   Wed Feb 15 20:58:56 2012 +0800
        
            Convert to HTML
        
        commit ed24602fa5fb09d1af03af30e12d3406781b09dd
        Author: Haoran Feng <harrifeng@gmail.com>
        Date:   Wed Feb 15 20:43:45 2012 +0800
        
            Initial contents of public_html
      #+end_src
    + author和date很容易理解,而commit就是指的git用的一种ID叫做
      "Content-Addressable Name", 后面会讲到 
    + 我们还可以使用git show来查看某个commit id
      #+begin_src sh 
        $ git show ed24602fa5fb09d1af03af30e12d3406781b09dd
        
        commit ed24602fa5fb09d1af03af30e12d3406781b09dd
        Author: Haoran Feng <harrifeng@gmail.com>
        Date:   Wed Feb 15 20:43:45 2012 +0800
        
            Initial contents of public_html
        
        diff --git a/index.html b/index.html
        new file mode 100644
        index 0000000..34217e9
        --- /dev/null
        +++ b/index.html
        @@ -0,0 +1 @@
        +My website is alive!
      #+end_src
    + 如果我们不知道commit id,那么我们可以用git show-branch来查看代码库里面的分
      支, 默认只显示最新的,所以我们要加一个参数--more=10
      #+begin_src sh 
        $ git show-branch --more=10
        [master] Convert to HTML
        [master^] Initial contents of public_html
      #+end_src
*** Viewing Commit Differences
    + 我们可以用git diff来对比两个commit id
      #+begin_src sh 
        $ git diff ed24602fa5fb09d1af03af30e12d3406781b09dd \
        3fa3f7afbc62195565a8a70649fe02dbe2ce3061
        
        diff --git a/index.html b/index.html
        index 34217e9..b74b202 100644
        --- a/index.html
        +++ b/index.html
        @@ -1 +1,5 @@
        -My website is alive!
        +<html>
        +  <body>
        +    My website is alive!
        +  </body>
        +</html>
      #+end_src
*** Removing and Renaming Files in Your Respository
    + 删除的过程也需要两步:git rm 和 git commit
     #+begin_src sh 
       $ git rm poem.html 
       $ rm 'poem.html'
       > git commit -m "Remove a poem"
       [master 32f4eb9] Remove a poem
        1 files changed, 0 insertions(+), 1 deletions(-)
        delete mode 100644 poem.html
     #+end_src
    + 重命名的过程依然有两步 git mv和git commit
      #+begin_src sh
        $ git mv foo.html bar.html
        $ git commit -m "Move foo to bar"
        [master b732219] Move foo to bar
         1 files changed, 0 insertions(+), 0 deletions(-)
         rename foo.html => bar.html (100%) 
      #+end_src
    + git是move操作和其他相似的VCS不同,它是基于内容相似度的一种操作,后面会讲到
*** Making a Copy of Your Repository
    + 我们可以通过git clone来完整的复制一个代码库, 这个和cp -a 命令不一样,因为并
      不是所有的东西都是复制的,在.git文件夹中有些东西会改变的
      #+begin_src sh 
        $ git clone public_html my_website
        Cloning into my_website...
        done.
      #+end_src
*** Configuration Files
    + 对于git来说,主要的配置文件有如下三个:
      - /etc/gitconfig: 这个是系统的git配置信息,需要你有相应的权限才能改写,但是
        这个文件是优先级最低的,很可能在其他的位置,或者压根就不存在.如果有的话,是
        配置某一台host上面的git信息
      - ~/.gitconfig: 通过"~"我们可以知道,这个是一台host上面某个用户的git配置信
        息.这个在设置的时候要用到 --global
        #+begin_src sh 
          > git config --global user.email "fenghaoran18@gmail.com"
        #+end_src
      - .git/config: 这个是在.git文件夹下的,也就是每个项目不同的配置信息,一个用
        户可能有好几个项目,并不一定都要一样的用户名和用户邮箱, 这个在设置的时候,
        不要用 --global参数
        #+begin_src sh 
          > git config user.email "harrifeng@gmail.com"
        #+end_src

    + 下面这个例子可以看出配置文件的区别,这个用户一般用harrifeng@gmail.com但是为
      了public_html,他选择了fenghaoran10@gmail.com
      #+begin_src sh 
        > cat ~/.gitconfig 
        [user]
            name = Haoran Feng
            email = harrifeng@gmail.com
        > cat ~/public_html/.git/config
        [core]
            repositoryformatversion = 0
            filemode = true
            bare = false
            logallrefupdates = true
            ignorecase = true
        [user]
            email = fenghaoran10@gmail.com
        > pwd
        /Users/fenghaoran/public_html
        > git config -l
        user.name=Haoran Feng
        user.email=harrifeng@gmail.com
        core.repositoryformatversion=0
        core.filemode=true
        core.bare=false
        core.logallrefupdates=true
        core.ignorecase=true
        user.email=fenghaoran10@gmail.com
      #+end_srcb
    + 如果你想覆盖原来的设置的话,重新再设置一遍就自动覆盖了        
    + 如果我们想删除某些设置,我们可以用--unset来取消某些设置:
      #+begin_src sh 
        > git config --unset --global user.email
        > git config -l
        user.name=Haoran Feng
        core.repositoryformatversion=0
        core.filemode=true
        core.bare=false
        core.logallrefupdates=true
        core.ignorecase=true
        user.email=fenghaoran10@gmail.com
      #+end_src
*** Configuring an Alians
    + 我们可以通过下面的方法把git log --graph --abbrev-commit --pretty=oneline
      重命名为git show-graph
      #+begin_src sh 
        > git config --global alias.show-graph 'log --graph --abbrev-commit --pretty=oneline'
        > git show-graph
        
        ,* b732219 Move foo to bar
        ,* 3107dd6 add foo
        ,* d0fe499 <E8><BE><BE><E5><88><B0>
        ,* 32f4eb9 Remove a poem
        ,* 5c776e9 add poem
        ,* 3fa3f7a Convert to HTML
        ,* ed24602 Initial contents of public_html
      #+end_src



* Chapter 4: Basic Git Concepts
** Repositories
   + 像其他的VCS一样, git保留了整个项目的所有代码,不同的是,git还把代码库的信息都
     复制保存了一份.
   + 当然了,代码库中的配置信息部分,比如user.name啦, email.address啦不是复制保存
     的,是根据不同的用户保存的不同的信息
   + 除了配置信息和代码本身,在.git里面最重要的就是代码库信息(repository data),
     Git保存了两种代码库信息:
     - object store
     - index
** Git Object Types
   + Git的核心存储方式就是object store,数据信息,用户资料,log信息,版本信息,分支信
     息等等都是存在object store里面
   + Git的object store有如下四种:
     1) Blobs: Blob是 binary large object的缩写,所谓blob就是在计算中指那些内部是
        二进制,我们对内部的内容也不感兴趣的文件.blob甚至不包括文件名这类信息,在
        文件系统中,和blob相似的是data block
     2) Tree: 代表了内部代码的文件夹信息
     3) Commits: 一个commit object保存了某次提交的用户,提交者,提交时间,log信息,
        每个commit都是和一个tree object相对应的
     4) Tags: 我们知道每次我们commit都有一个commit ID通常是一个20位的十六进制数,
        我们想要更容易的读取,那么就用Tag
   + 所有这些信息最终都是压缩以后存储的
** Index
   + index是一个保存repository的内部架构的数据结构, 在后面我们会看到,index在
     merge方面,以及让多个版本的相同文件共存方面,有非常重要的作用
   + 在git中index的作用,是在工作目录和代码库之间多加了一层(也就是说在git commit
     之前多加了个git add, add就是说add到index, 然后从index提交到代码库)
** Content-Addressable Names
   + Git是通过把文件内容通过SHA1哈希之后,得到了一个40-digit的十六进制数
   + 每一个微小的改动,都会导致这个数的改变,而完全相同的内容,SHA1哈希也保证能够生
     成完全相同的40-digit数
** Git Tracks Content
   + Git 对于文件内容的执着,导致了它如下的两个特性:
     1) Git的object store是基于文件内容的哈希的,和文件名字没有任何的关系
     2) Git的内部不是存储一个文件,然后每次存储对这个文件的增删改查,而是每当有一
        点改动,也存储一个新的版本.这是由于git按照文件内容哈希的本质决定的
   + 从用户角度看到的Git可以区分出版本信息,并且能从一个版本到另外一个版本,完全都
     是编造出来的.
** Pathname Versus Content
   + 和其他的VCS一样,git也需要保存一系列的文件列表.但是,这并不意味着我们一定要存
     储文件名. 实际上,Git把文件名当成是和文件内容不相关的信息.
   + 像传统的数据库的理论一样,Git把index和data区别开来了
     | System               | Index mechanism   | Data store                 |
     | Traditional database | ISAM              | Data records               |
     | Unix filesystem      | Directories       | Blocks of data             |
     | Git                  | .git/objects/hash | Blob objects, tree objects |

** Object Store Pictures
   + 我们来看看object store的架构:
     1) blob object是最基本的内容存储,他不会引用其他的object store,但是会被tree
        object给引用
     2) tree object会指向blob,或者其他的tree. tree object会被commit object引
        用,tree所起到的作用和文件系统中的文件夹是一样的,tree用来表达不同文件之间
        的关系
     3) commit会指向一个tree objcet, 这个tree object是被这个commit引入到代码库里
        面来的. 而后来的commit会指向前面的commit,也就是说parent commit是头指针.
     4) tag是和最多一个commit相互联系的
     5) branch不是一个git的概念,但是它对于commit里面的信息有很重要作用.
** Inside the .git directory
   + 如果我们新建一个空的代码库,在.git文件夹下,会有很多的隐藏文件,这些文件我们不
     用过于在意,git有一些plumbing命令来处理这些文件,但是我们一般用不到
     #+begin_src js 
       > mkdir ~/tmp/hello
       > cd ~/tmp/hello
       > git init
       Initialized empty Git repository in /Users/fenghaoran/tmp/hello/.git/
       > find .
       .
       ./.git
       ./.git/branches
       ./.git/config
       ./.git/description
       ./.git/HEAD
       ./.git/hooks
       ./.git/hooks/applypatch-msg.sample
       ./.git/hooks/commit-msg.sample
       ./.git/hooks/post-commit.sample
       ./.git/hooks/post-receive.sample
       ./.git/hooks/post-update.sample
       ./.git/hooks/pre-applypatch.sample
       ./.git/hooks/pre-commit.sample
       ./.git/hooks/pre-rebase.sample
       ./.git/hooks/prepare-commit-msg.sample
       ./.git/hooks/update.sample
       ./.git/info
       ./.git/info/exclude
       ./.git/objects
       ./.git/objects/info
       ./.git/objects/pack
       ./.git/refs
       ./.git/refs/heads
       ./.git/refs/tags
     #+end_src
   + 一般情况下, .git/objects文件夹是空的(除了某些占位符)
     #+begin_src sh 
       > find .git/objects
       .git/objects
       .git/objects/info
       .git/objects/pack
     #+end_src
   + 而如果我们加入了某些文件,则这个文件夹下会多出关于这个文件的id信息
     #+begin_src sh 
       > echo "hello world" > hello.txt
       > git add hello.txt
       > find .git/objects
       .git/objects
       .git/objects/3b
       .git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad
       .git/objects/info
       .git/objects/pack
     #+end_#+begin_src c++ 
     #+end_src

** Objects, Hashes, and Blobs
   + 当我们有新文件创建的时候,git不太关系文件名字,而是关心文件的内容,因为他会把
     内容通过SHA1 哈希以后,得到一个id,来唯一标示这个文件,这个哈希结果通常是一个
     40bytes的字符串,而刚才我们的试验中字符串是38bytes的,这是因为在某些操心系统
     中,如果一个文件夹下有太多的文件,那么文件系统就会变得特别的慢,所以git在前两
     个byte加入一个"/"把所有的文件分成了256个子文件夹,这也是为什么上面的例子中
     会出现一个3b文件夹
   + 我们可以通过hash id来找到我们的内容, 如果你不太记得id是啥了,可以通过
     rev-parse来查询
     #+begin_src sh 
       > cd ~/tmp/hello
       > git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad
       hello world
       > git rev-parse 3b18e512
       3b18e512dba79e4c8300dd08aeb37f8e728b8dad
     #+end_#+begin_src c++ 
     #+end_src

** Files and Trees
   + 我们已经为内容找好了id,那文件名呢,我们如何保存代码库中的文件名,没有文件名版
     本管理也就没有意义了,我们前面说过,git通过tree 这个object store来保存路径信
     息,但是当你仅仅add的时候,是不会创建tree的,而先会在.git/index里面保留文件的
     来龙去脉.刚add完之后index的内容如下
     #+begin_src sh 
       > git ls-files -s
       100644 3b18e512dba79e4c8300dd08aeb37f8e728b8dad 0   hello.txt
     #+end_src
   + 如果我们commit的话,会产生新的tree object store,但是我们也可以通过write-tree
     命令来强制它产生tree. 我们可以看到一个tree就和一个文件夹是一样的,其内部的内
     容就是文件的路径信息. 也可以这么理解git write-tree其实就是 git add "folder"
     #+begin_src sh 
       > git write-tree
       68aba62e560c0ebc3396e8ae9335232cd93a3f60
       
       > find .git/objects
       .git/objects
       .git/objects/3b
       .git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad
       .git/objects/68
       .git/objects/68/aba62e560c0ebc3396e8ae9335232cd93a3f60
       .git/objects/info
       .git/objects/pack
     #+end_src
   + 为了证实我们关于tree其实就是一个文件夹的想法,我们通过git cat-file来看一下
     tree的内容为何, 可以看到,其实就是关于路径的信息,我们又用同样的命令来看了
     hello.txt的id,可以得到hello.txt的内容
     #+begin_src sh 
       > git cat-file -p 68aba6
       100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    hello.txt
       > git cat-file -p 3b18e
       hello world
     #+end_src
** A Note on Git's Use of SHA1
   + 相同内容导致的hash id相同,不叫碰撞,只有不同的内容产生了相同的hash id才叫碰
     撞呢.
   + 所以,你一旦在某个代码库里面找到了一个hash id,你就能确信,这个id对应的内容一
     定是你希望的. 同样的,如果一旦一个hash id没有被找到,那说明这里面肯定没有你想
     要的内容
   + 我们在来看一下most recent commit, 它一定会包含自己的parent commit以及parent
     commit 的tree.因为最开始的commit是根,所以最开始的commit能够标示整个项目
   + hash function在对比文件方面,有其巨大优势,可以有效的对比两个文件,即便两者非
     常的大.
** Tree Hierachies
   + 下面我通过新建一个subdir来研究,发现新创建了一个tree 4924, 而这个tree里面有
     两种文件,一个是hello.txt,另一个是subdir这个文件夹. 而subdir这个文件夹的id
     (68aba62)表明,它就是利用的原来的顶级文件夹(~/tmp/hello/), 因为题目的内容都
     相同,都是只有一个叫做hello.txt的文件,这个文件里面,就一句话"hello world"
     #+begin_src sh 
       > pwd
       /Users/fenghaoran/tmp/hello
       > mkdir subdir
       > cp hello.txt subdir/
       > git add subdir/hello.txt 
       > git write-tree
       492413269336d21fac079d4a4672e55d5d2147ac
       > git cat-file -p 4924
       100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    hello.txt
       040000 tree 68aba62e560c0ebc3396e8ae9335232cd93a3f60    subdir
     #+end_src
   + 我们还发现subdir的类型不再是blob了,而变成了tree.
   + 通过find命令,我们也发现,相比于上一步,我们仅仅多了一个文件夹,这个文件夹里面
     包含一个subdir文件夹和hello.txt
     #+begin_src sh 
       > find .git/objects
       .git/objects
       .git/objects/3b
       .git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad
       .git/objects/49
       .git/objects/49/2413269336d21fac079d4a4672e55d5d2147ac
       .git/objects/68
       .git/objects/68/aba62e560c0ebc3396e8ae9335232cd93a3f60
       .git/objects/info
       .git/objects/pack
     #+end_src
** Commits
   + 我们也可以通过如下的管道操作来达到创建commit的目的
     #+begin_src sh 
       > echo -n "Commit a file that syas hello\n" | git commit-tree 492413269336d21fac079d4a4672e55d5d2147ac
       0a9f5a02b15245e71748387cda37f47b9195b63c
       > git cat-file -p 0a9f
       tree 492413269336d21fac079d4a4672e55d5d2147ac
       author haoran feng <fenghaoran18@gmail.com> 1329550638 +0800
       committer haoran feng <fenghaoran18@gmail.com> 1329550638 +0800
       
       Commit a file that syas hello
     #+end_src
   + 这一次生成的commit id就不再会是和教材上面相同的了,因为commit会包括用户名,邮
     箱,创建时间等等. 一个基本的commit信息就包括了:
     - 对应的tree: 一般一个commit对应一个tree,一个tree却可以有多个commit对应它.
     - 谁添加了这个新版本,添加的时间
     - 谁提交了这个新版本,提交时间
     - commit description
** Tags
   + 存在两种tag类型:
     1) lightweight tags是对应于一个commit object,并且是每个代码库私有的.并不会
        创建object
     2) annotated tag更为具体,而且会创建object,默认是这种tag,因为他是永久的
   + tag的方法如下,我们也可以通过cat-file来查看tag的信息
     #+begin_src sh 
       # 0a9f refers a commit id
       > git tag -m"Tag version 1.0" V1.1 0a9f
       > git rev-parse V1.1
       0f5c44fa6e2a89fdce3c1ec84640b566b44d7774
       > git cat-file -p 0f5c44
       object 0a9f5a02b15245e71748387cda37f47b9195b63c
       type commit
       tag V1.1
       tagger haoran feng <fenghaoran18@gmail.com> Sat Feb 18 16:14:11 2012 +0800
       
       Tag version 1.0
     #+end_src
   + Git通常是对一个commit来进行tag,所代表的就是一个tree,通过这个tree就代表了当
     时所有的文件.这和CVS里面对一个文件进行tag是不同的













* Chapter 5: File Management and the Index
  + 传统的版本管理系统是你在工作目录编辑好之后,直接commit到代码库,而git则多加了
    一层叫做index的,你要在工作目录编辑好之后,add到index,然后再提交到代码库
  + 其实在提交到index这一层有很多的工作,比如add, remove, move等等,这些重要的工作
    其实在commit之前就做好了.
  + 在Git里面提交分成了两步:stage change & commit change. 但是如果你是add或者
    change一个文件的话,可以简单的利用下面这一步
    #+begin_src sh 
      > git commit index.html
    #+end_src
** It's All About the Index
   + 虽然Git的高端命令一直在试图隐藏index,但是作为一个程序员,你还是时刻要记得
     index的存在, 无论何时,你都可以利用git status来查看当前index的status
** File Classifications in Git
   + Git把你的文件分成了三类:
     1) Tracked: 已经被index所收录的文件
     2) Ignored: 被忽略的文件,比如编辑器生成的临时文件, 编译器生成的目标文件等等,我
        们可以通过设置.gitignore来设置哪些文件被忽略
     3) 如果不是前面两种,那么就是第三种:没有被index收录的文件
   + 如果我们新创建一个文件的话,通常是untracked的
     #+begin_src sh 
       > cd ~/tmp/my_stuff/
       > git init
       Initialized empty Git repository in /Users/fenghaoran/tmp/my_stuff/.git/
       > git status
       # On branch master
       #
       # Initial commit
       #
       nothing to commit (create/copy files and use "git add" to track)
       > echo "New data" > data
       > git status
       # On branch master
       #
       # Initial commit
       #
       # Untracked files:
       #   (use "git add <file>..." to include in what will be committed)
       #
       #   data
       nothing added to commit but untracked files present (use "git add" to track)
     #+end_src
   + 我们可以通过更改.gitignore来忽略某些文件
     #+begin_src sh 
       > touch main.o
       > git status
       # On branch master
       #
       # Initial commit
       #
       # Untracked files:
       #   (use "git add <file>..." to include in what will be committed)
       #
       #   data
       #   main.o
       nothing added to commit but untracked files present (use "git add" to track)
       > echo main.o > .gitignore
       > git status
       # On branch master
       #
       # Initial commit
       #
       # Untracked files:
       #   (use "git add <file>..." to include in what will be committed)
       #
       #   .gitignore
       #   data
       nothing added to commit but untracked files present (use "git add" to track)
     #+end_src
** Using git add
   + 我们可以通过git add来吧untrack的文件给track到index里面
    #+begin_src sh 
      > git status
      # On branch master
      #
      # Initial commit
      #
      # Untracked files:
      #   (use "git add <file>..." to include in what will be committed)
      #
      #   .gitignore
      #   data
      nothing added to commit but untracked files present (use "git add" to track)
      > git add data .gitignore 
      > git status
      # On branch master
      #
      # Initial commit
      #
      # Changes to be committed:
      #   (use "git rm --cached <file>..." to unstage)
      #
      #   new file:   .gitignore
      #   new file:   data
      #
    #+end_src
   + 从Git object model的角度 add之后,马上文件的SHA1 name就生成好了,然后被放
     到.git文件夹下.所以add file又叫"caching file" 或者"putting a file in the index"
** Using git commit --all
   + 我们可以通过git -all 或者 git -a来自动把所有unstaged的file给stage掉,然后
     commit,下面这个例子中ready和notyet都是原来在代码库中的(已经至少提交过一次),
     然后ready是再次更改然后add了, notyet是再次更改没有add, suddir是新建的文件夹,
     而new是subdir里面的新建的文件(我们发现git并没有发现它)
     #+begin_src sh 
       > mkdir subdir
       > echo Nope >> subdir/new
       > git status
       # On branch master
       # Changes to be committed:
       #   (use "git reset HEAD <file>..." to unstage)
       #
       #   modified:   ready
       #
       # Changes not staged for commit:
       #   (use "git add <file>..." to update what will be committed)
       #   (use "git checkout -- <file>..." to discard changes in working directory)
       #
       #   modified:   notyet
       #
       # Untracked files:
       #   (use "git add <file>..." to include in what will be committed)
       #
       #   subdir/
     #+end_src
   + 我们调用commit -all会发现只有两个文件被commit,而subdir是新文件夹,而这个文件
     夹中没有文件被track,那么这个文件夹就是空的(对于git来说),空文件的话git是不会
     去track的
     #+begin_src sh 
         1                                                                                 
         2 # Please enter the commit message for your changes. Lines starting              
         3 # with '#' will be ignored, and an empty message aborts the commit.             
         4 # On branch master                                                              
         5 # Changes to be committed:                                                      
         6 #   (use "git reset HEAD <file>..." to unstage)                                 
         7 #                                                                               
         8 #   modified:   notyet                                                          
         9 #   modified:   ready                                                           
        10 #                                                                               
        11 # Untracked files:                                                              
        12 #   (use "git add <file>..." to include in what will be committed)              
        13 #                                                                               
        14 #   subdir/
     #+end_src
** Writing Commit Log Messages
   + 如果你没有通过-m来写log,那么就会给你在默认editor里面打开文件让你填写log, 如
     果这个时候你后悔了的话,可以填一个空的commit log, git不会提交一个log为空的
     commit的
** Using git rm
   + git rm是和git add相反的,不过它不仅仅把文件从代码库中移除,而且同时会把代码从
     工作目录中移除. 如果想仅仅从代码库中移除,我们可以git rm --cahed(尽量不要用
     这个方法,因为你会经常的忘掉的)
     #+begin_src sh 
       > echo "Random stuff" > oops
       > git rm opps
       fatal: pathspec 'opps' did not match any files
       > git add oops
       > git status
       # On branch master
       #
       # Initial commit
       #
       # Changes to be committed:
       #   (use "git rm --cached <file>..." to unstage)
       #
       #   new file:   .gitignore
       #   new file:   data
       #   new file:   oops
       #
       > git ls-files --stage
       100644 0487f44090ad950f61955271cf0a2d6c6a83ad9a 0   .gitignore
       100644 e476983f39f6e4f453f0fe4a859410f63b58b500 0   data
       100644 fcd87b055f261557434fa9956e6ce29433a5cd1c 0   oops
       > git rm --cached oops
       rm 'oops'
       > git ls-files --stage
       100644 0487f44090ad950f61955271cf0a2d6c6a83ad9a 0   .gitignore
       100644 e476983f39f6e4f453f0fe4a859410f63b58b500 0   data
     #+end_src
   + 如果我们想删除一个已经被提交的代码,那么很简单,就是git rm filename就可以.如
     果不小心误删了,我们可以通过checkout HEAD来取回
     #+begin_src sh 
       > git rm data
       rm 'data'
       > git status
       # On branch master
       # Changes to be committed:
       #   (use "git reset HEAD <file>..." to unstage)
       #
       #   deleted:    data
       #
       > git checkout HEAD -- data
       > cat data
       New data
       And some more data now
       > git status
       # On branch master
       nothing to commit (working directory clean)
     #+end_src
   + 如果我们git rm的时候, 当前的文件相对于index中,已经改变了,那么我们需要加一
     个-f才能强制删除(git为了防止放弃没有保存的修改)
     #+begin_src sh 
       > echo "2" >> data
       > git status
       # On branch master
       # Changes not staged for commit:
       #   (use "git add <file>..." to update what will be committed)
       #   (use "git checkout -- <file>..." to discard changes in working directory)
       #
       #   modified:   data
       #
       no changes added to commit (use "git add" and/or "git commit -a")
       > git rm data
       error: 'data' has local modifications
       (use --cached to keep the file, or -f to force removal)
     #+end_src
** Using git mv
   + 如果我们想更改一个文件的名字,或者移动一个文件,可以用git mv
     #+begin_src sh 
       > git mv data mydata
       > git status
       # On branch master
       # Changes to be committed:
       #   (use "git reset HEAD <file>..." to unstage)
       #
       #   renamed:    data -> mydata
       #
       > git commit -m"Moved data to mydata"
       [master af10b99] Moved data to mydata
        1 files changed, 0 insertions(+), 0 deletions(-)
        rename data => mydata (100%)
     #+end_src
   + 查看被重命名过的文件的历史记录需要--follow
     #+begin_src sh 
       > git log mydata
       commit af10b99dba133773f8cf05acaae61ebc2092b391
       Author: haoran feng <fenghaoran18@gmail.com>
       Date:   Sun Feb 19 15:32:53 2012 +0800
       
           Moved data to mydata
       > git log --follow mydata
       commit af10b99dba133773f8cf05acaae61ebc2092b391
       Author: haoran feng <fenghaoran18@gmail.com>
       Date:   Sun Feb 19 15:32:53 2012 +0800
       
           Moved data to mydata
       
       commit 7caba47386e31cd5b6bc2faba985f1dee8f41678
       Author: haoran feng <fenghaoran18@gmail.com>
       Date:   Sun Feb 19 15:06:23 2012 +0800
       
           Add some files
     #+end_src
** A Note on Tracking Renames
   + 传统的VCS在面对rename的时候,都是非常头疼的,因为传统的VCS是只保存两个版本之
     间的不同,如果你要move一个文件,对于他们来说,就和先删除原文件里面的所有的行,
     然后再把所有的行再粘贴再重命名后的文件里面.
   + 为了克服这个问题,Subversion开始对rename的情况进行特殊的单独处理,这也就意味
     着你必须使用svn mv而不是svn rm和svn add, 从下面的例子你可以看到Git能够聪明
     的认识这是个重命名,即便是先rm再add
     #+begin_src sh 
       > mv mydata yourdata
       > git rm mydata
       rm 'mydata'
       > git add yourdata 
       > git status
       # On branch master
       # Changes to be committed:
       #   (use "git reset HEAD <file>..." to unstage)
       #
       #   renamed:    mydata -> yourdata
       #
       > git commit -m "rename again to test wether git can understand rm & add -> mv"
       [master e6f37c0] rename again to test wether git can understand rm & add -> mv
        1 files changed, 0 insertions(+), 0 deletions(-)
        rename mydata => yourdata (100%)
       > git log --follow yourdata
       commit e6f37c0c67ce8a4edc2097ab0308e78f43c24262
       Author: haoran feng <fenghaoran18@gmail.com>
       Date:   Sun Feb 19 15:48:51 2012 +0800
       
           rename again to test wether git can understand rm & add -> mv
       
       commit af10b99dba133773f8cf05acaae61ebc2092b391
       Author: haoran feng <fenghaoran18@gmail.com>
       Date:   Sun Feb 19 15:32:53 2012 +0800
       
           Moved data to mydata
       
       commit 7caba47386e31cd5b6bc2faba985f1dee8f41678
       Author: haoran feng <fenghaoran18@gmail.com>
       Date:   Sun Feb 19 15:06:23 2012 +0800
       
           Add some files
     #+end_src
   + Git之所以能够如此聪明的识别rename,在于Git把data和index分开了, 文件之间的关
     系都是由tree保留的,通过hash后git发现文件内容不变(也就是bolb不变), 变的只是
     tree,那么就很容易得出这是一个rename的操作,无论你是git mv 还是git rm &
     git add
** The .gitignore File
   + 我们前面说过了如果你有某些文件不想被加入到版本里面,那么就要设置.gitignore文
     件.
   + 这个文件对当前文件夹的文件和子文件夹起作用的,如果子文件夹有特殊需求,那就在
     子文件里面再加一个.gitgnore,前面的要求,可以通过"!"命令来修正,比如下面的例子,所
     有的*.o文件都不会被加到版本管理里面,但是vendor_files文件夹下面的driver.o文
     件却可以.
     #+begin_src sh 
       > cd my_package/
       > cat .gitignore 
       ,*.o
       
       > cd my_package/vendor_files/
       > cat .gitignore 
       !driver.o
     #+end_src
   + .gitignore既然是设置在非.git文件夹下,那么就是一个正常的文件,在clone的时候,
     每个用户的代码库中都会有一份,如果你想让这个被忽略的文件列表只对你个人成立,
     那么请把规则写到.git/info/exclude 这个文件

* Chapter 6: Commits
  + 我们前面讲过了,当我们git add, git mv的时候,其实我们是把变化提交到index
  + 而commit就是把index的结果提交到代码库了
  + Git 通过比较当前的index和上次的index来判断新增加了哪些文件和文件夹,他会为新
    增加的文件创建blob,为新增加的文件夹创建tree
  + commit之间是有相互顺序关系的,后提交的commit会指向前面的commit
** Atomic Changesets
   + 所有的commit都是原子操作:要么全部更新成功,要么全部更新失败
** Identifying Commits
   + 如何来找一个commit呢?最准确的方法,当然是commit ID.
   + 其他的方法当然还有最近一次的commit的别名叫做 HEAD
   + 还可以用relative name来找前几次的commit
** Absolute Commit Names
   + 40-hex-digit的 Commit ID无疑是最准确的ID, 它是全局唯一的(不仅仅是在自己的代
     码库里面)
   + 40-hex-digit的ID实在是太长了,在特定代码库里面,我们允许用一些前缀来代替
     #+begin_src sh 
       > git log -1 --pretty=oneline HEAD
       adf2a1e16625b7bed13ef21becde2bae431bf196 daily2
       > git log -1 --pretty=oneline abf2a
       fatal: ambiguous argument 'abf2a': unknown revision or path not in the working tree.
       Use '--' to separate paths from revisions
       > git log -1 --pretty=oneline adf2
       adf2a1e16625b7bed13ef21becde2bae431bf196 daily2
     #+end_src
** refs and symrefs
   + ref 是一个SHA1 hash ID指向Git object store的
   + symbolic ref就是symref,是指向一个Git object的名字(通常是英文的)
   + 每一个symbolic ref都有一个明确的全称,而这些全称有三个namespace:
     - .git/refs/heads/ref : local branch的symref的前缀
     - .git/refs/remotes/ref: remote tracking branch的symref的前缀
     - .git/refs/tags/ref: tag的symref的前缀
   + 举个例子,比如经常我们会起一个branch name叫做dev,其实他的全称是
     refs/heads/dev,一个tag叫做v.2.6.23,其实是refs/tags/v2.6.23
   + 如果你的tag和branch同名,而且你没有用全名,那么git就会从.git的列表的某个顺序
     开始找,先找到哪个算哪个
   + 如下四个symref最常用:
     - HEAD: 指向当前branch最近的提交,每当branch改变,自动指向最新
     - ORIG_HEAD: ORIG_HEAD就是HEAD的前一次commit
     - FETCH_HEAD: 我们以后会接触到一个git fetch命令,这个命令会记录所有branch的
       head在.git/FETCH_HEAD里面. FETCH_HEAD就是最新得到的branch的head
     - MERGE_HEAD: 当进行merge的时候,其他branch的head的symref就是MERGE_HEAD
** Relative Commit Names
   + Git同样也提供了通过相对的路径来寻找某个commit,比如master^就是master的前一次
     提交
   + 相对commit主要是靠两个符号:
     1) 插入符(^): 插入符用来在有多个parent的情况下选择某个parent比如对于提交C,
        C^1就是他的第一个parent, C^2是第二个parent, C^3是第三个parent
     2) 波浪号(~): 波浪号是在寻找更远的直系亲属(parent的parent)比如对于提交C,
        C~1是它的父亲, C~2就是它的祖父, C~3是曾祖父等等
   + 我们可以通过git rev-parse 和 git show-branch来查看commit历史,并解析这些相对
     的名字:
     #+begin_src sh
       c:/github/flask $ git show-branch --more=35 | tail -10
       [master~15^2^2] Added PasswordField in docs/patterns/wtforms.rst
       [master~16] Mention that people subscribe with **extra.
       [master~17] Subscribe to signals with extra kwargs in the docs
       [master~18] Added a newline
       [master~19] Merge branch '0.8-maintenance'
       [master~19^2] Removed a newline
       [master~20] Added support for anchor link generation.
       [master~21] Merge branch '0.8-maintenance'
       [master~19^2^] Fixed an issue with an unused module for Python 2.5 (flask.session)
       [master~19^2~2] Prepare for an 0.8.1 release
       c:/github/flask $ git rev-parse master~19^2~2
       766522cb587850f643f3bb6cb011735ae6a98510
       c:/github/flask $ git rev-parse master
       e940c8e024bbf5def4cda3dff3820604907b1571
     #+end_src
** Commit History & View Old Commits
   + 我们可以通过git log命令来查看所有的commit, 从某种意义上来说git log就是git
     log HEAD的简称,它会从最新的一条commit显示到最开始的一条.
   + 这也就是说,我们可以git log ref或者 git log commit ID来从某一条显示
   + 当然,也可以设定一个区间,在区间里面的commit才显示, 比如下例就是显示的从
     倒数第一到倒数第四个这总共四个commit的信息
     #+begin_src sh 
       c:/github/flask $ git log --pretty=short --abbrev-commit master~5..master~1
       commit 94c007f
       Author: Harri Feng <fenghaoran18@gmail.com>
       
           update
       
       commit ca4aec9
       Author: Harri Feng <fenghaoran18@gmail.com>
       
           can show admin
       
       commit a9726c4
       Author: Armin Ronacher <armin.ronacher@active-4.com>
       
           Updated mod_wsgi docs to reference the sys.path hackery
       
       commit c90858a
       Author: Armin Ronacher <armin.ronacher@active-4.com>
       
           Added a branch to test functionality enabled by new test client
     #+end_src
   + 参数-p用来打印此次commit引入的改变, 注意,如果不加限定还是会从尾打到头,所以
     下面的例子用-1来限定只打印一个
     #+begin_src sh
       c:/github/MyWay/TMP $ git log -1 -p master
       commit 1f50ab4d2272d42ba75f72b718c4f488fc467975
       Author: haoran feng <fenghaoran18@gmail.com>
       Date:   Tue Feb 21 22:54:33 2012 +0800
       
           daily for chapter 6
       
       diff --git a/TMP/version_control_git.org b/TMP/version_control_git.org
       index bac4497..5aeaa7a 100644
       --- a/TMP/version_control_git.org
       +++ b/TMP/version_control_git.org
       @@ -925,5 +925,23 @@
               adf2a1e16625b7bed13ef21becde2bae431bf196 daily2
       ,      #+end_src
        ** refs and symrefs
       -   + 
       +   + ref 是一个SHA1 hash ID指向Git object store的
       +   + symbolic ref就是symref,是指向一个Git object的名字(通常是英文的)
       +   + 每一个symbolic ref都有一个明确的全称,而这些全称有三个namespace:
     #+end_src

   + 参数--stat用来统计某次commit引入的行, 注意这里如果不加以限定范围的话,还是会
     和log一样从尾打印到头. 下面的例子是从倒数第三打印到头.
     #+begin_src sh 
       c:/github/MyWay/TMP $ git log --stat master~3..master
       commit 1f50ab4d2272d42ba75f72b718c4f488fc467975
       Author: haoran feng <fenghaoran18@gmail.com>
       Date:   Tue Feb 21 22:54:33 2012 +0800
       
           daily for chapter 6
       
        TMP/version_control_git.org |   20 +++++++++++++++++++-
        1 files changed, 19 insertions(+), 1 deletions(-)
       
       commit 167ddc015929c41dea00ab3868170032f86c6f82
       Author: haoran feng <fenghaoran18@gmail.com>
       Date:   Tue Feb 21 22:25:49 2012 +0800
       
           daily
       
        TMP/version_control_git.org |   31 +++++++++++++++++++++++++++++--
        1 files changed, 29 insertions(+), 2 deletions(-)
       
       commit ed8a398a906d14ad2b9ac7524771f0eef04baefa
       Author: haoran feng <fenghaoran18@gmail.com>
       Date:   Sun Feb 19 16:24:18 2012 +0800
       
           finish chapter 5
       
        TMP/version_control_git.org |  111 ++++++++++++++++++++++++++++++++++++++++++-
        1 files changed, 109 insertions(+), 2 deletions(-)
     #+end_src
  + 我们还可以通过git show来查看object store
** Commit Graphic
   + 可以用命令 gitk来查看版本信息的图片格式
** Commit Ranges
   + 可以通过".."符号来隔开两个版本,然后显示这两个版本之间的版本信息,比如
     M~12..M~10 的意思就是第11老和第10老的commit, 都是从当前的最近的一次提交算作
     最新的一次commit. 值得注意的是,这里是"前开后闭"的方式来取range的.也就是说是
     (12, 10], 所以range里面不包括第12老的commit
   + 我们还可以通过前置的(^)来剔除某些我们不想要的值,比如git log ^X Y其实就是和
     log X..Y一样,因为默认前开后闭么.
   + 我们可以通过一个例子来加深理解,HEAD就是最近一次的提交,所谓的master~2就是相
     对于HEAD来说是距离为2
     #+begin_src sh
       c:/tmpfile $ git log master
       commit 9ded61f6601d0b9ebaa563e43a5bb6f382eb5fee
       Author: harrifeng <fenghaoran18@gmail.com>
       Date:   Thu Mar 1 22:47:48 2012 +0800
       
           commit 3
       
       commit 00d0b820c03b8cb85dd0d1e8c1a4c591bc0ab5f7
       Author: harrifeng <fenghaoran18@gmail.com>
       Date:   Thu Mar 1 22:42:42 2012 +0800
       
           commit 2
       
       commit 3bbd42824af9c8ccfe4999263fb3f19b4f74908e
       Author: harrifeng <fenghaoran18@gmail.com>
       Date:   Thu Mar 1 22:42:23 2012 +0800
       
           commit 1
       c:/tmpfile $ git log master~..HEAD
       commit 9ded61f6601d0b9ebaa563e43a5bb6f382eb5fee
       Author: harrifeng <fenghaoran18@gmail.com>
       Date:   Thu Mar 1 22:47:48 2012 +0800
       
           commit 3
       c:/tmpfile $ git log master~2..master~1
       commit 00d0b820c03b8cb85dd0d1e8c1a4c591bc0ab5f7
       Author: harrifeng <fenghaoran18@gmail.com>
       Date:   Thu Mar 1 22:42:42 2012 +0800
       
           commit 2     
       c:/tmpfile $ git log master~2..master
       commit 9ded61f6601d0b9ebaa563e43a5bb6f382eb5fee
       Author: harrifeng <fenghaoran18@gmail.com>
       Date:   Thu Mar 1 22:47:48 2012 +0800
       
           commit 3
       
       commit 00d0b820c03b8cb85dd0d1e8c1a4c591bc0ab5f7
       Author: harrifeng <fenghaoran18@gmail.com>
       Date:   Thu Mar 1 22:42:42 2012 +0800
       
           commit 2
     #+end_src
   + 这里的range的(start, end]中的start和end可以是各种别名,比如master..dev,这些
     情况都比较复杂,我们只介绍其中比较简单的情况,比如下图, 所谓topic..master就是
     说,所有不在topic,而在master里面的commit, 那么就只剩下commit v 和 commit x了,
     T和U被排除的原因是他们为topic的C做了贡献
     #+begin_example
       +-----+      +-----+       +-----+       +-----+
       |  A  |----->|  B  | ----->|  C  | ----->|  D  |          topic
       +-----+      +-----+   --->+-----+       +-----+
                             /  
                            /    
       +-----+      +------/      +-----+       +-----+
       |  T  |----->|  U  | ----->|  V  | ----->|  X  |          master
       +-----+      +-----+       +-----+       +-----+
       
                range topic..master == v, x
            
     #+end_example
   + 在看下面的情况, 这次topic是merge到master里面去的.所以T,U都没有对topic做过贡
     献topic..master就剩下了T,U,V,X
     #+begin_example
       +-----+      +-----+ 
       |  A  |----->|  B  |                                      topic
       +-----+      +-----+--      
                             \  
                              \  
       +-----+      +------    - >+-----+       +-----+
       |  T  |----->|  U  | ----->|  V  | ----->|  X  |          master
       +-----+      +-----+       +-----+       +-----+
       
                range topic..master == T, U, V, X
     #+end_example
   + 最后一种情况最复杂, 先branch,然后merge. 最终的结果是W,X,Y,Z 因为无论如何,这
     四个commit都没有影响到topic分支
     #+begin_example
        +-----+       +-----+       +-----+      +-----+ 
        |  A  | ----->|  B  | ----->|  C  |----->|  D  |                                topic
        +-----+       +-----+   --->+-----+      +-----+--      
                               /                          \  
                             -/                            \  
        +-----+       +-----+       +-----+      +------    - >+-----+       +-----+
        |  U  | ----->|  V  | ----->|  W  |----->|  X  | ----->|  Y  | ----->|  Z  |    master
        +-----+       +-----+       +-----+      +-----+       +-----+       +-----+
                
                range topic..master = W, X, Y, Z
            
     #+end_example

     



    


