* Chapter 1: Introduction
  + Background:
    主要就是介绍凡是一切可以保存不同版本信息的工具都叫Version Control System
  + The Birth of Git:
    Git的诞生是因为Linux内核开发开源软件,和如下几个特殊的特性的需要,而产生的:
    - 需要支持分布式开发:
      新的VCS必须能够让不同的私有代码库在不用和主代码库进行频繁同步的情况下独自
      开发
    - 可以能够应付数以万计的开发者:
    - 能够快速有效的进行运行:
    - 保证数据的完整性:
      使用了SHAQ 算法来校验
    - 为每一次提交强制保留注释
    - 某些代码必须不能改动
    - 操作必须有原子性
    - 必须而且要鼓励分支开发(branched development)
    - 每一个开发者的本地信息足够丰富,可以在不查询中心服务器的情况下,了解自己的版
      本历史
    - 内部设计要简洁
  + Precedents
    我们也有必要来了解一下VCS的历史:
    1) 第一个成功的VCS是SCCS, 这个软件发明了repository这个词,用来表示中心代码库,
       同时提供了一直简单的锁文件的方法:如果一个用户想要运行代码,那么就要保证代
       码是unlock的状态,然后把代码check out出来并且加锁.等编辑完之后再check in并
       且unlock,简言之就是一旦要check out就一定保证在server端加锁,这样其他人就不
       能使用这些代码了
    2) 1986年诞生的CVS,更改了SCCS每次一个文件只能有一个人更改的策略,转而给一个文
       件的不同用户都有写的权限,然后当两个用户写完时,再进行merge,如果两者改动了
       同一行,那么要手动进行merge,否则CVS可以自动为用户进行merge
    3) CVS自身的各种问题,导致了新一代VCS的诞生,那就是SVN, SVN对CVS系统的贡献是:
       能够自动提交代码并且对分支支持的更好
    4) 第四代的VCS就是以BitKeeper和Mercurial为代表了,他们的更改非常激进:他们摒弃
       了中央代码库的设计,让代码进行分布式存储,每一个用户都有一份可分享的拷贝.Git正
       是继承了这种P2P的存储方式
    5) Git又从Mercurial那里学到了利用文件内容来进行唯一判定文件的方法
  + Time Line
  + What's in a Name?
* Chapter 2: Instlling Git
  + Using Linux Binary Distributions:
    在Debian/Ubuntu上面有:
    - git-core: git主要的文件
    - git-arch, git-cvs, git-svn: 从其他VCS里面导入到git中需要的软件
    - git-gui, gitk, gitweb:是三种gui或者web的显示方式
    - git-email:用邮件发送Git patch
    - git-daemon-run: 通过匿名的下载来分享你的代码库(github上面下载zip包应该就是
      利用了这个程序)
* Chapter 3: Getting Started
** The Git Command Line
    + git中有很多的option, 这些option有些是为git服务的(比如下面的--version),有些
      是为subcommand服务的(比如下面的--amend)
      #+begin_src sh 
        $ git --version
        git version 1.6.0
        
        $ git commit --amend
      #+end_src
    + git命令同时兼容长的和短的option,比如
      #+begin_src sh 
        $ git commit -m "Fixed a typo."
        $ git commit --message="Fixed a type"
      #+end_src
    + 上面的message 这个长参数使用了"--"来隔开,在git里面,为了突出filename,也经常
      用到"--":下面第一个例子里面tools/Makefile就是一个文件. 第一个main.c为一个
      tag name,而第二个main.c为一个filename
      #+begin_src sh 
        $git diff -w master origin -- tools/Makefile
        
        #Checkout the tag named "main.c"
        $ git checkout main.c
        
        #Checkout the file named "main.c"
        $ git checkout -- main.c
      #+end_src
** Quick Introduction to Using Git
*** Creating an Initial Repository
    + 我们建立一个文件夹,然后把他初始化为git repository:
      #+begin_src sh 
        $ mkdir ~/public_html
        $ cd ~/public_html
        $ echo 'My website is alive!' > index.html
        # turn public_html into a Git repository
        $ git init
      #+end_src
    + 我们可以发现git repository的过程,并不需要当前文件夹为空,而git init的结果就
      是在public_html下面建立了一个.git的隐藏文件夹,即便在public_html文件夹里面
      再建立其他文件夹也不会产生其他.git文件夹了,这个是Git又和其他VCS不一样的地
      方,它所有的信息都存在了这一个文件夹里面.
*** Adding a File to Your Repository
    + 我们把一个文件加入到代码库的方法如下, 然后查看当前repository信息
      #+begin_src sh 
        $ git add index.html
        $ git status
        # On branch master
        #
        # Initial commit
        #
        # Changes to be committed:
        #   (use "git rm --cached <file>..." to unstage)
        #
        #   new file:   index.html
        #
      #+end_src
    + 如果真正的想把文件提交到代码库,需要commit:
      #+begin_src sh 
        $ git commit -m "Initial contents of public_html" \
            --author="Haoran Feng <harrifeng@gmail.com>"
        [master (root-commit) ed24602] Initial contents of public_html
         Author: Haoran Feng <harrifeng@gmail.com>
         1 files changed, 1 insertions(+), 0 deletions(-)
         create mode 100644 index.html
      #+end_src
    + 之后再看status,就发现没有需要提交的代码了
    + 之所以要把代码提交分成add和commit两个阶段,我想是因为commit一定要写注释,而
      且多次的add, remove等操作都是不需要的.一系列有意义的add remove change才需
      要写一次注释,从而进行一次commit. 进而也不至于使得代码库过于凌乱
      #+begin_src sh 
        $ git status
        # On branch master
        nothing to commit (working directory clean)
      #+end_src
 
        








      
      

*** Configuring the Commit Author
    + 为了不每次都设置用户名和邮箱名,我们可以在开始把这些基本信息都设置好:
      #+begin_src sh 
        $ git config user.name "Haoran Feng"
        $ git config user.email "harrifeng@gmail.com"
      #+end_src
*** Making Another Commit
    + 我们可以对index.html进行一次更改,然后进行提交,如此一来,这个文件就有两个版
      本了
*** Viewing Your Commits
    + 我们可以通过git log来取出历次commit的信息
      #+begin_src sh 
        $ git log
        
        commit 3fa3f7afbc62195565a8a70649fe02dbe2ce3061
        Author: Harri Feng <fenghaoran18@gmail.com>
        Date:   Wed Feb 15 20:58:56 2012 +0800
        
            Convert to HTML
        
        commit ed24602fa5fb09d1af03af30e12d3406781b09dd
        Author: Haoran Feng <harrifeng@gmail.com>
        Date:   Wed Feb 15 20:43:45 2012 +0800
        
            Initial contents of public_html
      #+end_src
    + author和date很容易理解,而commit就是指的git用的一种ID叫做
      "Content-Addressable Name", 后面会讲到 
    + 我们还可以使用git show来查看某个commit id
      #+begin_src sh 
        $ git show ed24602fa5fb09d1af03af30e12d3406781b09dd
        
        commit ed24602fa5fb09d1af03af30e12d3406781b09dd
        Author: Haoran Feng <harrifeng@gmail.com>
        Date:   Wed Feb 15 20:43:45 2012 +0800
        
            Initial contents of public_html
        
        diff --git a/index.html b/index.html
        new file mode 100644
        index 0000000..34217e9
        --- /dev/null
        +++ b/index.html
        @@ -0,0 +1 @@
        +My website is alive!
      #+end_src
    + 如果我们不知道commit id,那么我们可以用git show-branch来查看代码库里面的分
      支, 默认只显示最新的,所以我们要加一个参数--more=10
      #+begin_src sh 
        $ git show-branch --more=10
        [master] Convert to HTML
        [master^] Initial contents of public_html
      #+end_src
*** Viewing Commit Differences
    + 我们可以用git diff来对比两个commit id
      #+begin_src sh 
        $ git diff ed24602fa5fb09d1af03af30e12d3406781b09dd \
        3fa3f7afbc62195565a8a70649fe02dbe2ce3061
        
        diff --git a/index.html b/index.html
        index 34217e9..b74b202 100644
        --- a/index.html
        +++ b/index.html
        @@ -1 +1,5 @@
        -My website is alive!
        +<html>
        +  <body>
        +    My website is alive!
        +  </body>
        +</html>
      #+end_src
*** Removing and Renaming Files in Your Respository
    + 删除的过程也需要两步:git rm 和 git commit
     #+begin_src sh 
       $ git rm poem.html 
       $ rm 'poem.html'
       > git commit -m "Remove a poem"
       [master 32f4eb9] Remove a poem
        1 files changed, 0 insertions(+), 1 deletions(-)
        delete mode 100644 poem.html
     #+end_src
    + 重命名的过程依然有两步 git mv和git commit
      #+begin_src sh
        $ git mv foo.html bar.html
        $ git commit -m "Move foo to bar"
        [master b732219] Move foo to bar
         1 files changed, 0 insertions(+), 0 deletions(-)
         rename foo.html => bar.html (100%) 
      #+end_src
    + git是move操作和其他相似的VCS不同,它是基于内容相似度的一种操作,后面会讲到
*** Making a Copy of Your Repository
    + 我们可以通过git clone来完整的复制一个代码库, 这个和cp -a 命令不一样,因为并
      不是所有的东西都是复制的,在.git文件夹中有些东西会改变的
      #+begin_src sh 
        $ git clone public_html my_website
        Cloning into my_website...
        done.
      #+end_src
*** Configuration Files
    + 对于git来说,主要的配置文件有如下三个:
      - /etc/gitconfig: 这个是系统的git配置信息,需要你有相应的权限才能改写,但是
        这个文件是优先级最低的,很可能在其他的位置,或者压根就不存在.如果有的话,是
        配置某一台host上面的git信息
      - ~/.gitconfig: 通过"~"我们可以知道,这个是一台host上面某个用户的git配置信
        息.这个在设置的时候要用到 --global
        #+begin_src sh 
          > git config --global user.email "fenghaoran18@gmail.com"
        #+end_src
      - .git/config: 这个是在.git文件夹下的,也就是每个项目不同的配置信息,一个用
        户可能有好几个项目,并不一定都要一样的用户名和用户邮箱, 这个在设置的时候,
        不要用 --global参数
        #+begin_src sh 
          > git config user.email "harrifeng@gmail.com"
        #+end_src

    + 下面这个例子可以看出配置文件的区别,这个用户一般用harrifeng@gmail.com但是为
      了public_html,他选择了fenghaoran10@gmail.com
      #+begin_src sh 
        > cat ~/.gitconfig 
        [user]
            name = Haoran Feng
            email = harrifeng@gmail.com
        > cat ~/public_html/.git/config
        [core]
            repositoryformatversion = 0
            filemode = true
            bare = false
            logallrefupdates = true
            ignorecase = true
        [user]
            email = fenghaoran10@gmail.com
        > pwd
        /Users/fenghaoran/public_html
        > git config -l
        user.name=Haoran Feng
        user.email=harrifeng@gmail.com
        core.repositoryformatversion=0
        core.filemode=true
        core.bare=false
        core.logallrefupdates=true
        core.ignorecase=true
        user.email=fenghaoran10@gmail.com
      #+end_srcb
    + 如果你想覆盖原来的设置的话,重新再设置一遍就自动覆盖了        
    + 如果我们想删除某些设置,我们可以用--unset来取消某些设置:
      #+begin_src sh 
        > git config --unset --global user.email
        > git config -l
        user.name=Haoran Feng
        core.repositoryformatversion=0
        core.filemode=true
        core.bare=false
        core.logallrefupdates=true
        core.ignorecase=true
        user.email=fenghaoran10@gmail.com
      #+end_src
*** Configuring an Alians
    + 我们可以通过下面的方法把git log --graph --abbrev-commit --pretty=oneline
      重命名为git show-graph
      #+begin_src sh 
        > git config --global alias.show-graph 'log --graph --abbrev-commit --pretty=oneline'
        > git show-graph
        
        ,* b732219 Move foo to bar
        ,* 3107dd6 add foo
        ,* d0fe499 <E8><BE><BE><E5><88><B0>
        ,* 32f4eb9 Remove a poem
        ,* 5c776e9 add poem
        ,* 3fa3f7a Convert to HTML
        ,* ed24602 Initial contents of public_html
      #+end_src













* Chapter 4: Basic Git Concepts
** Repositories
   + 像其他的VCS一样, git保留了整个项目的所有代码,不同的是,git还把代码库的信息都
     复制保存了一份.
   + 当然了,代码库中的配置信息部分,比如user.name啦, email.address啦不是复制保存
     的,是根据不同的用户保存的不同的信息
   + 除了配置信息和代码本身,在.git里面最重要的就是代码库信息(repository data),
     Git保存了两种代码库信息:
     - object store
     - index
** Git Object Types
   + Git的核心存储方式就是object store,数据信息,用户资料,log信息,版本信息,分支信
     息等等都是存在object store里面
   + Git的object store有如下四种:
     1) Blobs: Blob是 binary large object的缩写,所谓blob就是在计算中指那些内部是
        二进制,我们对内部的内容也不感兴趣的文件.blob甚至不包括文件名这类信息,在
        文件系统中,和blob相似的是data block
     2) Tree: 代表了内部代码的文件夹信息
     3) Commits: 一个commit object保存了某次提交的用户,提交者,提交时间,log信息,
        每个commit都是和一个tree object相对应的
     4) Tags: 我们知道每次我们commit都有一个commit ID通常是一个20位的十六进制数,
        我们想要更容易的读取,那么就用Tag
   + 所有这些信息最终都是压缩以后存储的
** Index
   + index是一个保存repository的内部架构的数据结构, 在后面我们会看到,index在
     merge方面,以及让多个版本的相同文件共存方面,有非常重要的作用
   + 在git中index的位置和文件系统中的文件夹差不多
** Content-Addressable Names
   + Git是通过把文件内容通过SHA1哈希之后,得到了一个40-digit的十六进制数
   + 每一个微小的改动,都会导致这个数的改变,而完全相同的内容,SHA1哈希也保证能够生
     成完全相同的40-digit数
** Git Tracks Content
   + Git 对于文件内容的执着,导致了它如下的两个特性:
     1) Git的object store是基于文件内容的哈希的,和文件名字没有任何的关系
     2) Git的内部不是存储一个文件,然后每次存储对这个文件的增删改查,而是每当有一
        点改动,也存储一个新的版本.这是由于git按照文件内容哈希的本质决定的
   + 从用户角度看到的Git可以区分出版本信息,并且能从一个版本到另外一个版本,完全都
     是编造出来的.
** Pathname Versus Content
   + 和其他的VCS一样,git也需要保存一系列的文件列表.但是,这并不意味着我们一定要存
     储文件名. 实际上,Git把文件名当成是和文件内容不相关的信息.
   + 像传统的数据库的理论一样,Git把index和data区别开来了
     | System               | Index mechanism   | Data store                 |
     | Traditional database | ISAM              | Data records               |
     | Unix filesystem      | Directories       | Blocks of data             |
     | Git                  | .git/objects/hash | Blob objects, tree objects |

** Object Store Pictures
   + 我们来看看object store的架构:
     1) blob object是最基本的内容存储,他不会引用其他的object store,但是会被tree
        object给引用
     2) tree object会指向blob,或者其他的tree. tree object会被commit object引用
     3) commit会指向一个tree objcet, 这个tree object是被这个commit引入到代码库里
        面来的. 而后来的commit会指向前面的commit,也就是说parent commit是头指针.
     4) tag是和最多一个commit相互联系的
     5) branch不是一个git的概念,但是它对于commit里面的信息有很重要作用.


  
     
