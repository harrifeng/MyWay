* chapter 1: 引论
** 本书讨论的内容
   + 作者首先举例了Kth element和字谜游戏的问题，算法的优势就是能降低复杂度，从而
     在面对数据量的时候，比较从容。这也就是这本书要讨论的内容
** 数学知识复习
*** 指数:
    + 2^N + 2^N = 2^(N+1)
*** 对数
    + 在计算机科学中，所有对数都是以2为底的
    + logAB = logA + logB
*** 级数
    + sumof(A^i | 0<=i<=N) = (A^(N+1) - 1)/A-1
    + 推演方法
      #+begin_src c
        S = 1 + A^1 + A^2 + A^3 ...
        AS =    A^1 + A^2 + A^3 + A^4...
        S - AS = 1
        S = 1/(1 - A)
      #+end_src
    + 我们经常使用A=2时候的情况:sumof(2^i | 0<=i<=N) = 2^(N+1) - 1
*** 模运算
    + 如果N整除A-B,那么就说A与B模N同余
** 递归的简单介绍
   + 当一个函数用自身来定义时，就称为递归的。
   + 递归的特点就是需要某些基准情况，它们不用递归就能算出来。
     #+begin_src c++
       int f(int x)
       {
           /* Base Case */
           if (x == 0)
               return 0;
           else
               return 2 * f(x - 1) + x * x;
       }
     #+end_src
   + 打印输出整数是一个很好的递归的例子，这个例子还有个局部的优化方法:使用
     n-(n/10)*10 来代替n%10, 因为mod这个过程消耗很大
     #+begin_src c++
       #include <iostream>
       using namespace std;
       
       void printOut(int n)
       {
           if (n >= 10)
               printOut(n / 10);
           /*
            *use n - (n / 10) * 10 is more effective than mod, as 
            *mod is very costly for CPU
            *cout << n - (n / 10) * 10;
            */
           cout << n % 10;
       }
       
       int main(int argc, const char *argv[])
       {
           printOut(123459);    
           cout << endl;
           return 0;
       }
     #+end_src
   + 递归要确保所有递归调用都能运行，在逻辑上不能又错误
   + 最后，递归最好能满足合成效益法则:在求解一个问题的同一实例时，切勿在不同的递
     归调用中做重复的工作。比如，使用递归来计算斐波那契数之类的简单函数值不是一
     个特别好的注意，就是因为递归中有很多重复的操作。

* chapter 2: 算法分析
** 数学基础
   + 主要就是说了大O复杂度分析法
** 模型
** 要分析的问题
** 运行时间计算
*** 运行时间中的对数
    + 二分查找法:二分查找法因为每次都会去掉一半的搜索项目，所以最后的复杂度是O(lgN)
    + 欧几里得算法:是求两个整数的最大公约数的算法，也就是我们常说的辗转相除算法
    + 幂运算:求幂的话，最明显的是使用N-1次的乘法自乘，但是还有更高效的运算方法，
      那就是利用递归:
      #+begin_src c++
        long pow(long x, int n)
        {
            if (n == 0)
                return 1;
            if (n == 1)
                return x;
            if (isEven(n))
                return pow(x * x, n / 2);
            else
                return pow(x * x, n / 2) * x;
        }
      #+end_src
* chapter 3: 表，栈和队列
** 抽象数据类型:
   + ADT就是对一种数据结构一系列的增删改查操作
** 表ADT:
*** 表的简答数组实现
    + 如果对表的操作通常是在末尾插入元素，之后只有数组访问，在这种情况下，数组是
      实现表比较好的方式
    + 表的弱点就是插入和删除代价昂贵
*** 简单链表
    + 克服数组形式表插入删除代价昂贵的缺点，产生了链表
*** STL的向量和表
    + 在STL中，数组实现表的代表就是vector，链表实现表的代表就是list，其中在list
      是双向链表。
    + vector和list都支持的函数如下:
      - int size() const
      - void clear()
      - bool empty()
      - void push_back(const Object& x)
      - void pop_back() 
      - const Object &back() const
      - const Object &front() const
    + vector在头部插入效率不高，所以下面两个函数只被list支持
      - void push_front(const Object &x)
      - void pop_front()
    + vector的特点是数据内存在一块，所以有以下特殊函数
      - Object& operator[]
      - Object& at(int idx)
      - int capacity() const
      - void reserve(int new Capacity)
*** 迭代器
    + 获得迭代器的方法:
      - iterator begin()
      - iterator end()
    + 迭代器方法
      - itr++ & ++itr
      - *itr
      - itr1 == itr2 如果两者指向同一个位置才为true
    + 需要迭代器的容器操作
      - iterator insert(iterator pos, Object &x)
      - iterarot erase(iterator pos)
      - iterator erase(iterator start, iterator end)
*** const_iterator
    + const_iterator和iterator的主要区别，是const_iterator的operator*返回常量引
      用，这样const_iterator类型的*iter就不能出现在赋值语句的左边
** 向量的实现
** 表的实现
** 栈ADT
*** 栈模型
*** 栈的实现
    + 栈可以很容易的用vector和list来实现
*** 应用
    + 栈在计算机科学中的应用有:
      1) 平衡符号:也就是我们常说的括号匹配
      2) 中缀表达式到后缀表达式的转换
      3) 后缀表达式的计算
      4) 函数的调用
    + 其中，四则表达式的计算就用到了上面提到的(2)和(3): 我们阅读常用的中缀表达式
      作为输入，先利用栈把中缀表达式转化成后缀表达式，然后计算后缀表达式的值，就
      可以得到四则运算的结果。
    + 尾递归:在程序最后一行进行的递归，叫做尾递归，尾递归是非常差劲的使用递归的
      方法，可以通过将代码放到while循环中加以去除，如下
      #+begin_src c
        template <typename Iterator>
        void print(Iterator start, Iterator end, ostream &out = cout)
        {
            if (start == end)
                return;
        
            out << *start++ << endl; // Print and advance start
            print(start, end, out);
        }
        /* previous recursive code can be replaced by following code */
        template <typename Iterator>
        void print(Iterator start, Iterator end, ostream &out = cout)
        {
            while (true)
            {
                if (start == end)
                    return;
                out << *start++ << endl; // Print and advance start
            }
        }
      #+end_src
** 队列ADT
*** 队列模型
    + 如果说栈是后进先出的话，队列就是先进先出
*** 队列的数组实现
    + 队列的数组实现是通过"循环数组"来避免队列在front和back两个图标到达数组尾部
      的情况的。
    + "循环数组"的设计，要求我们要记录数组的长度。因为会出现front在back后面但是
      却合法的情况
*** 队列的应用
    + 看似是常识般的队列，却在算法中有非常重要的应用，比如广度优先算法就是借助于
      队列的帮助
* chapter 4:树
** 预备知识
   +对于大量的输入数据，链表线性访问的时间太长了，不宜使用，所以我们要引入新的数
   据结构:树
*** 树的实现
    + 如果树的子结点数目不限制，那么就是一个传统意义上的树，这种树却由于子结点的
      不固定性，不容易编码实现。
** 二叉树
   + 容易编码实现，且最终应用广泛的，是二叉树
*** 实现
    + 一个二叉树的典型实现如下:
      #+begin_src c
        struct BinaryNode
        {
            Object      element;
            BinaryNode  *left;
            BinaryNode  *right;
        };
      #+end_src
*** 一个例子-表达式树
    + 我们前面说的表达式，如果树叶代表操作数，其他结点代表操作符的话，整个树就可
      以代表一个四则运算。
** 查找树ADT-二叉查找树
   + 对于一个普通的二叉树来说，最代表性的两个操作就是insert和remove
*** insert
    + insert其实就是和contains非常像，对于一个元素如果在指定地方没有找到它，我们
      就该在那个地方插入这个元素
      #+begin_src c++
        /**
         * Internal method to insert into a subtree
         * x is the item to insert
         * t is the node that roots the subtree, t maybe
         * modified, so no const is applied.
         * Set the new root of the subtree.
         */
        void insert(const Comparable &x, BinaryNode* &t)
        {
            /* if the fuction is contains, do nothing here */
            if (t == NULL)
                t = new BinaryNode(x, NULL, NULL);
            else if (x < t->element)
                insert(x, t->left);
            else if (t->element > x)
                insert(x, t->right);
            /* if the fuction is contains, return true here,
               as we find the exact node! */
            else
                ; // Duplicate; do nothing
        }
      #+end_src
*** remove
    + remove的理解难度则要大一点，主要在两点:
      1) 如果要删除的结点有一个(或者零个)子结点的话，那么我们其实是，第一，用中
         间变量保存自己的地址，第二，把自己的地址赋成自己的子结点的内容，第三，
         把中间变量保存的那个地址里面的动态内存删掉。
      2) 理解了第1条，那么第二条比较好理解:如果要删除的结点有两个子结点的话，那
         么，直接删除是非常不明智的，我们采取把这个子节点的"右子树"的"最小结点"
         的值给我们，然后让去删除"右子树"的"最小结点",因为只有这个结点可以放到"
         根"的位置，而且它只会最多有一个子结点
      #+begin_src c++
        void remove(const Comparble &x, BinaryNode* &t)
        {
            if (t == NULL)
                return;    //Item not found, do nothing
            if (x < t->element)
                remove(x, t->left);
            else if(t->element < x)
                remove(x, t->right);
            else if (t->left != NULL && t->right != NULL) // two children
            {
                t->element = findMin(t->right)->element;
                remvoe(t->element, t->right);
            }
            else 
            {
                BinaryNode *oldNode = t; //temp variable
                t = (t->left != NULL) ? t->left : t->right;
                delete oldNode; // Do not need let oldNode = NULL, as we stil use it
            }
        }
      #+end_src
    
