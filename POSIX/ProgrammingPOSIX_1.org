* Chapter1 Introduction 
  + 在Unix系统里面，process就可以被看成是一种thread,另外加上address space, file descriptor 和一些其他数据。
  + 有些版本的Unix支持一些叫做"lightweight" 的process， 他们之所以被称之为lightweight，就是因为他们可以摆脱一些 
    甚至所有的数据，这样一来，可以提高他们的效率。
  + 虽然摆脱了数据的束缚，但是处理数据以外的其他一切东东，比如address space 和 file descriptor等等，这些lightweight
    process 还是需要的。这样一来，你就可以使用同一个address space，但是利用不同的thread，做不同的事情。
** The "bailing programmers"
   + 在这里作者举了个例子，讲一写programmer在快要沉的船上轮流向外舀水的故事，在这个故事当中，很多角色适合于Pthread：
     - Programmer 代表 thread
     - bailing bucket 代表在一段时间内只能由一个thread占有的东西，比如 shared data, or asynchronization object,
       主要的Pthread synchronization object叫做mutex
     - Nudges and shouts 代表同步的机制。 Pthread 提供了condition variables来传达shared data state的改变
** Definitions and terminology
*** Asynchronous
    + Asynchronous(异步) means that things happen independently unless there's some enforced dependency
    + Life is asynchronous. Events that are not dependent on one another can occur simultaneously.
    + Traditional computer programming, on the other hand, causes all events to occur in series unless
      the programmer takes "extraordinary measurement" to allow them to happen concurrently.
    + If you can start an asynchronous operation, but then you can do nothing but wait for it, you're
      not getting much benefit from the asynchrony.
*** Concurrency
    + Concurrency(并发) is used to refer to things that appear to happen at the same time, but which may
      occur serially.
    + Concurrency describes the behavior of threads or processes on a uniprocessor system.
    + The definition of concurrent execution in POSIX requires that "functions that suspend the execution
      of the calling thread shall not cause the execution of other threads to be indefinitely suspended.
    + Concurrency的做法在于让progress之间相互独立，这样一来不同的progress可以交叉运行，但是concurrency并不意味着
      这些process是同时运行的。
    + concurrency可以利用自己异步的优势，在其他independent operation运行的情况下，做自己的事情。
    + Pthread provide you with both concurrency and asynchrony, and the combination is exacly what you need
      to easily write responsive and efficient programs.
*** Uniprocessor and muliprocessor
    These term are easy to understand.
*** Parallelism
    + Parallelism (并行) describes _concurrent_ sequences that proceed _simultaneously_
    + That is to say, true parallellism can occur *only* on a multiprocessor system.
    + While concurrency can coccur on a uniprocessor because concurrency is, essentially, the illusion of
      parallelism.
    + Parallelism requires that a program be able to perform two computations at once, while concurrency
      requires that the programmer be able to pretend that two things can happen at once.(并发保证一个没做完
      另外一个也可以做，间或就可以，没一定要同时发生）
*** Thread safety and reentrancy
    + Thread-safe means that the code can be clled from umltiple threads without destructive result.
    + 这里只提到safe，并没有提到效率，其实如果真的想保证function的thread-safe，可以用mutex锁，这样一来其实只有一个
      thread在用function, 那肯定没有问题。
    + 更好的办法是把function内部分成小的不同的critical sections.这样不同的critical section可以被不同的thread来调用
    + 更上一层楼的办法是重新设计函数，让这些函数 protect critical data， 而不是critical code, 因为thread不会再同一时间
      使用同一data，这种设计方法可以保证fully parallel execution of the code.
    + 比如 /putchar/ function, 我们不应该把 /putchar/ 这个函数给lock住，而是应该associate the mutext with the stream
      也就是我们说的protecting the data rather the code.这样一来，你的thread如果想写stream就可以并行的使用 /putchar/
      了，而且can use the same mutex to safely coordinate their access to that stream
    + reentrant 其实就是efficiently thread-safe的同义词。要做到reentrant就要做到不依赖static data，最好不要依赖any form
      of synchronization between threads.
    + 一般来说a function can avoid internal synchronization by saving state in a "context structure" that is controlled
      by the caller. The caller is then responsible for any necessary synchronization of the data.
*** Concurrency control functions
    + Any "concurrent system" must provide a core set of essential functions that you need to create concurrent execution
      contexts:
      - Execution context: when one needs to wait for an external event, it must be able to continue a context from
        the point where it last executed, with the same register contents, at a later time
      - Scheduling (调度策略): determines which context (or set of contexts) should execute at any given pint in time, and
        switches between contexts when necessary
      - Synchronization (同步机制）： provides mechanisms for concurrent execution context to coordinate their use of shared
        resources.
    + 下面的表格可以清晰的表示上面的概念
      |---------------------+-------------------+--------------------------+---------------------------------|
      |                     | Execution context | Scheduling               | Synchronization                 |
      | Real traffic        | automobile        | traffic lights and signs | turn signals and barke lights   |
      | Unix(before threas) | process           | priority(nice)           | wait and pipes                  |
      | Pthreads            | thread            | policy, priority         | condition variables and mutexes |
** Asynchronous programming is intutive
   可能大家不知道，Unix就是一个asynchronous programming的实例。
*** because Unix is asynchronous
    + If you run the program in the background, it runs asynchronously with the shell.
    + /Time is a synchronization mechanism/
    + /Unix pipes and files can be synchronization mechanism/
    + 比如在Bash中 ls|more 其实bash就是同时开启了两个process. Both commands proceed concurrently (or even in parallel on a
      multiprocessor) with /ls/ supplying data and /more/ processing that data.
    + Unix process可以异步运转的主要原因是因为operating system save the state of one process and switch to another without
      affecting the operation of either.
    + Unix process 不及保留了足够的进程切换的信息，他们还额外的保留了些东西，比如address space和file descriptors.
    + Thread的诞生，正是轻量级的process，他们不再保留那些额外的东西(address space), 仅仅保留进程切换所需要的最基础的信息（如，寄存器），
      而那些额外的东西，在一个process里面的threads是共享的。
    + /Threads are "simpler" than processes./
    + 在process内部进行thread的切换非常的快捷，很大一部分的原因是由于threads within a process share the adrress space - code, data
      stack, everything.
*** because the world is asynchronous
    + Like moter vehicles move in parallel on a highway, and have to agree to certain conventions in order to avoid collisions,
      Threads must be coded to "agree" to rules that protect the program.
    + You need enough thread, but not too many； enough communication, but not too much. A key to good threaded programming is
      learning how to judge the proper balance for each situation.
** About the examples in this book
** Asynchronous programming, by example.
   + 下面就是我们第一个例子(alarm.c)它能够让我们提醒自己在600秒后做的事情，但可惜的是在这600秒里面，我们除了傻等，啥都不能做
   + The prgoram is doing something synchronously that you would probaly like to be asynchronous.
     #+begin_src c 
       #include "errors.h"
       
       int main(int argc, char *argv[])
       {
           int seconds;
           char line[128];
           char message[64];
       
           while (1) {
               printf("Alarm > ");
               if (fgets(line, sizeof(line), stdin) == NULL)
                   exit(0);
               if (strlen(line) <= 1)
                   continue;
               /*
                * Parse input line into seconds (%d) and a message
                * (%64[^\n]), consisting of up to 64 characters
                * separated from the seconds by whitespace.
                */
               if (sscanf(line, "%d %64[^\n]", &seconds, message) < 2){
                   fprintf(stderr, "Bad command\n");
               } else {
                   sleep(seconds);
                   printf("(%d) %s\n", seconds, message);
               }
           }
       }
     #+end_src
** A version using multiple processes
   + We will use alarm_fork.c to make the program asynchronous: you can enter commands at any time, and they will be carried
     out independently.
     #+begin_src c

       #include <sys/types.h>
       #include <wait.h>
       #include "errors.h"
       
       int main(int argc, char *argv[])
       {
           int status;
           char line[128];
           int seconds;
           pid_t pid;
           char message[64];
       
           while (1) {
               printf("Alarm > ");
               if (fgets(line, sizeof(line), stdin) == NULL)
                   exit(0);
               if (strlen(line) <= 1)
                   continue;
               /*
                * Parse input line into seconds (%d) and a message
                * (%64[^\n]), consisting of up to 64 characters
                * separated from the seconds by whitespace.
                */
               if (sscanf(line, "%d %64[^\n]", &seconds, message) < 2){
                   fprintf(stderr, "Bad command\n");
               } else {
                   pid = fork();
                   if (pid == (pid_t)-1)
                       errno_abort("Fork");
                   if (pid == (pid_t)0) {
                       /*
                        * In the child, wait and then print a message
                        */
                       sleep(seconds);
                       printf("(%d) %s\n", seconds, message);
                       exit(0);
                   } else {
                       /*
                        * In the parent, call waitpid() to collect children
                        * that have already terminated.
                        */
                       do {
                           pid = waitpid((pid_t)-1, NULL, WNOHANG);
                           if (pid == (pid_t)-1)
                               errno_abort("Wait for child");
                       } while (pid != (pid_t)0);
                   }
               }
           }
       }
     #+end_src
   + 这个方法是tcp/ip经常用的，那就是fork一个child来处理当前的情况。
** A version using multiple threads
   + alarm_thread.c version is much like the fork version, except that it uses threads
     instead of child processes to create asynchronous alarms.
   + 下面的程序用到如下的pthread函数
     - pthread_create: create a thread running the routine specified in the third argument(alarm_thread)， returning an identifier
       for the new thread to the variable referenced by thread.
     - pthread_detach: allows Pthreads to reclaim the thread's resources as soon as it terminates.
     - pthread_exit: terminates the calling thread
     - pthread_self: returns the calling thread's identifier.
     #+begin_src c
       #include <pthread.h>
       #include "errors.h"
       
       typedef struct alarm_tag{
           int  seconds;
           char message[64];
       }alarm_t;
       
       void *alarm_thread(void *arg)
       {
           alarm_t *alarm = (alarm_t*)arg;
           int status;
       
           status = pthread_detach(pthread_self());
           if (status != 0)
               err_abort(status, "Detach thread");
           sleep(alarm->seconds);
           printf("(%d) %s\n", alarm->seconds, alarm->message);
           free(alarm);
           return NULL;
       }
       
       int main(int argc, char *argv[])
       {
           int status;
           char line[128];
           alarm_t *alarm;
           pthread_t thread;
       
           while (1) {
               printf("Alarm > ");
               if (fgets(line, sizeof(line), stdin) == NULL)
                   exit(0);
               if (strlen(line) <= 1)
                   continue;
       
               alarm = (alarm_t*)malloc(sizeof(alarm_t));
               if (alarm == NULL)
                   errno_abort("Allocate alarm");
       
               /*
                * Parse input line into seconds (%d) and a message
                * (%64[^\n]), consisting of up to 64 charactesrs
                * separated from the seconds by whitespace.
                */
               if (sscanf(line, "%d %64[^\n]",
                          &alarm->seconds,
                          alarm->message) < 2) {
                   free(alarm);
               } else {
                   status = pthread_create(&thread, NULL, alarm_thread, alarm);
                   if (status != 0)
                       err_abort(status, "Create alarm thread");
               }
           }
       }
     #+end_src
** Summany
   + In the fork version, each alarm has an independent address space, copied from the main program.
     That means we can put the seconds and message values into local variables, once the
     child has been created (when fork returns), the parent can change the values withou
     affecting the alarm (as the child has its own copy).
   + In the threaded version, on the other hand, all threads share the same address space
     - so we call malloc to create a new structure for each alarm, which is passed to the
       new thread.
