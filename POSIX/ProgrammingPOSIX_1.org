* Chapter1 Introduction 
  + 在Unix系统里面，process就可以被看成是一种thread,另外加上address space, file descriptor 和一些其他数据。
  + 有些版本的Unix支持一些叫做"lightweight" 的process， 他们之所以被称之为lightweight，就是因为他们可以摆脱一些 
    甚至所有的数据，这样一来，可以提高他们的效率。
  + 虽然摆脱了数据的束缚，但是处理数据以外的其他一切东东，比如address space 和 file descriptor等等，这些lightweight
    process 还是需要的。这样一来，你就可以使用同一个address space，但是利用不同的thread，做不同的事情。
** The "bailing programmers"
   + 在这里作者举了个例子，讲一写programmer在快要沉的船上轮流向外舀水的故事，在这个故事当中，很多角色适合于Pthread：
     - Programmer 代表 thread
     - bailing bucket 代表在一段时间内只能由一个thread占有的东西，比如 shared data, or asynchronization object,
       主要的Pthread synchronization object叫做mutex
     - Nudges and shouts 代表同步的机制。 Pthread 提供了condition variables来传达shared data state的改变
** Definitions and terminology
*** Asynchronous
    + Asynchronous(异步) means that things happen independently unless there's some enforced dependency
    + Life is asynchronous. Events that are not dependent on one another can occur simultaneously.
    + Traditional computer programming, on the other hand, causes all events to occur in series unless
      the programmer takes "extraordinary measurement" to allow them to happen concurrently.
    + If you can start an asynchronous operation, but then you can do nothing but wait for it, you're
      not getting much benefit from the asynchrony.
*** Concurrency
    + Concurrency(并发) is used to refer to things that appear to happen at the same time, but which may
      occur serially.
    + Concurrency describes the behavior of threads or processes on a uniprocessor system.
    + The definition of concurrent execution in POSIX requires that "functions that suspend the execution
      of the calling thread shall not cause the execution of other threads to be indefinitely suspended.
    + Concurrency的做法在于让progress之间相互独立，这样一来不同的progress可以交叉运行，但是concurrency并不意味着
      这些process是同时运行的。
    + concurrency可以利用自己异步的优势，在其他independent operation运行的情况下，做自己的事情。
    + Pthread provide you with both concurrency and asynchrony, and the combination is exacly what you need
      to easily write responsive and efficient programs.
*** Uniprocessor and muliprocessor
    These term are easy to understand.
*** Parallelism
    + Parallelism (并行) describes _concurrent_ sequences that proceed _simultaneously_
    + That is to say, true parallellism can occur *only* on a multiprocessor system.
    + While concurrency can coccur on a uniprocessor because concurrency is, essentially, the illusion of
      parallelism.
    + Parallelism requires that a program be able to perform two computations at once, while concurrency
      requires that the programmer be able to pretend that two things can happen at once.(并发保证一个没做完
      另外一个也可以做，间或就可以，没一定要同时发生）
*** Thread safety and reentrancy
    + Thread-safe means that the code can be clled from umltiple threads without destructive result.
    + 这里只提到safe，并没有提到效率，其实如果真的想保证function的thread-safe，可以用mutex锁，这样一来其实只有一个
      thread在用function, 那肯定没有问题。
    + 更好的办法是把function内部分成小的不同的critical sections.这样不同的critical section可以被不同的thread来调用
    + 更上一层楼的办法是重新设计函数，让这些函数 protect critical data， 而不是critical code, 因为thread不会再同一时间
      使用同一data，这种设计方法可以保证fully parallel execution of the code.
    + 比如 /putchar/ function, 我们不应该把 /putchar/ 这个函数给lock住，而是应该associate the mutext with the stream
      也就是我们说的protecting the data rather the code.这样一来，你的thread如果想写stream就可以并行的使用 /putchar/
      了，而且can use the same mutex to safely coordinate their access to that stream
    + reentrant 其实就是efficiently thread-safe的同义词。要做到reentrant就要做到不依赖static data，最好不要依赖any form
      of synchronization between threads.
    + 一般来说a function can avoid internal synchronization by saving state in a "context structure" that is controlled
      by the caller. The caller is then responsible for any necessary synchronization of the data.
*** Concurrency control functions
    + Any "concurrent system" must provide a core set of essential functions that you need to create concurrent execution
      contexts:
      - Execution context: when one needs to wait for an external event, it must be able to continue a context from
        the point where it last executed, with the same register contents, at a later time
      - Scheduling (调度策略): determines which context (or set of contexts) should execute at any given pint in time, and
        switches between contexts when necessary
      - Synchronization (同步机制）： provides mechanisms for concurrent execution context to coordinate their use of shared
        resources.
    + 下面的表格可以清晰的表示上面的概念
      |---------------------+-------------------+--------------------------+---------------------------------|
      |                     | Execution context | Scheduling               | Synchronization                 |
      | Real traffic        | automobile        | traffic lights and signs | turn signals and barke lights   |
      | Unix(before threas) | process           | priority(nice)           | wait and pipes                  |
      | Pthreads            | thread            | policy, priority         | condition variables and mutexes |
** Asynchronous programming is intutive
   可能大家不知道，Unix就是一个asynchronous programming的实例。
*** because Unix is asynchronous
    + If you run the program in the background, it runs asynchronously with the shell.
    + /Time is a synchronization mechanism/
    + /Unix pipes and files can be synchronization mechanism/
    + 比如在Bash中 ls|more 其实bash就是同时开启了两个process. Both commands proceed concurrently (or even in parallel on a
      multiprocessor) with /ls/ supplying data and /more/ processing that data.
    + Unix process可以异步运转的主要原因是因为operating system save the state of one process and switch to another without
      affecting the operation of either.
    + Unix process 不及保留了足够的进程切换的信息，他们还额外的保留了些东西，比如address space和file descriptors.
    + Thread的诞生，正是轻量级的process，他们不再保留那些额外的东西(address space), 仅仅保留进程切换所需要的最基础的信息（如，寄存器），
      而那些额外的东西，在一个process里面的threads是共享的。
    + /Threads are "simpler" than processes./
    + 在process内部进行thread的切换非常的快捷，很大一部分的原因是由于threads within a process share the adrress space - code, data
      stack, everything.
*** because the world is asynchronous
    + Like moter vehicles move in parallel on a highway, and have to agree to certain conventions in order to avoid collisions,
      Threads must be coded to "agree" to rules that protect the program.
    + You need enough thread, but not too many； enough communication, but not too much. A key to good threaded programming is
      learning how to judge the proper balance for each situation.
** About the examples in this book
** Asynchronous programming, by example.
   + 下面就是我们第一个例子(alarm.c)它能够让我们提醒自己在600秒后做的事情，但可惜的是在这600秒里面，我们除了傻等，啥都不能做
   + The prgoram is doing something synchronously that you would probaly like to be asynchronous.
     #+begin_src c 
       #include "errors.h"
       
       int main(int argc, char *argv[])
       {
           int seconds;
           char line[128];
           char message[64];
       
           while (1) {
               printf("Alarm > ");
               if (fgets(line, sizeof(line), stdin) == NULL)
                   exit(0);
               if (strlen(line) <= 1)
                   continue;
               /*
                * Parse input line into seconds (%d) and a message
                * (%64[^\n]), consisting of up to 64 characters
                * separated from the seconds by whitespace.
                */
               if (sscanf(line, "%d %64[^\n]", &seconds, message) < 2){
                   fprintf(stderr, "Bad command\n");
               } else {
                   sleep(seconds);
                   printf("(%d) %s\n", seconds, message);
               }
           }
       }
     #+end_src
** A version using multiple processes
   + We will use alarm_fork.c to make the program asynchronous: you can enter commands at any time, and they will be carried
     out independently.
     #+begin_src c

       #include <sys/types.h>
       #include <wait.h>
       #include "errors.h"
       
       int main(int argc, char *argv[])
       {
           int status;
           char line[128];
           int seconds;
           pid_t pid;
           char message[64];
       
           while (1) {
               printf("Alarm > ");
               if (fgets(line, sizeof(line), stdin) == NULL)
                   exit(0);
               if (strlen(line) <= 1)
                   continue;
               /*
                * Parse input line into seconds (%d) and a message
                * (%64[^\n]), consisting of up to 64 characters
                * separated from the seconds by whitespace.
                */
               if (sscanf(line, "%d %64[^\n]", &seconds, message) < 2){
                   fprintf(stderr, "Bad command\n");
               } else {
                   pid = fork();
                   if (pid == (pid_t)-1)
                       errno_abort("Fork");
                   if (pid == (pid_t)0) {
                       /*
                        * In the child, wait and then print a message
                        */
                       sleep(seconds);
                       printf("(%d) %s\n", seconds, message);
                       exit(0);
                   } else {
                       /*
                        * In the parent, call waitpid() to collect children
                        * that have already terminated.
                        */
                       do {
                           pid = waitpid((pid_t)-1, NULL, WNOHANG);
                           if (pid == (pid_t)-1)
                               errno_abort("Wait for child");
                       } while (pid != (pid_t)0);
                   }
               }
           }
       }
     #+end_src
   + 这个方法是tcp/ip经常用的，那就是fork一个child来处理当前的情况。
** A version using multiple threads
   + alarm_thread.c version is much like the fork version, except that it uses threads
     instead of child processes to create asynchronous alarms.
   + 下面的程序用到如下的pthread函数
     - pthread_create: create a thread running the routine specified in the third argument(alarm_thread)， returning an identifier
       for the new thread to the variable referenced by thread.
     - pthread_detach: allows Pthreads to reclaim the thread's resources as soon as it terminates.
     - pthread_exit: terminates the calling thread
     - pthread_self: returns the calling thread's identifier.
       #+begin_src c
       #include <pthread.h>
       #include "errors.h"
       
       typedef struct alarm_tag{
           int  seconds;
           char message[64];
       }alarm_t;
       
       void *alarm_thread(void *arg)
       {
           alarm_t *alarm = (alarm_t*)arg;
           int status;
       
           status = pthread_detach(pthread_self());
           if (status != 0)
               err_abort(status, "Detach thread");
           sleep(alarm->seconds);
           printf("(%d) %s\n", alarm->seconds, alarm->message);
           free(alarm);
           return NULL;
       }
       
       int main(int argc, char *argv[])
       {
           int status;
           char line[128];
           alarm_t *alarm;
           pthread_t thread;
       
           while (1) {
               printf("Alarm > ");
               if (fgets(line, sizeof(line), stdin) == NULL)
                   exit(0);
               if (strlen(line) <= 1)
                   continue;
       
               alarm = (alarm_t*)malloc(sizeof(alarm_t));
               if (alarm == NULL)
                   errno_abort("Allocate alarm");
       
               /*
                * Parse input line into seconds (%d) and a message
                * (%64[^\n]), consisting of up to 64 charactesrs
                * separated from the seconds by whitespace.
                */
               if (sscanf(line, "%d %64[^\n]",
                          &alarm->seconds,
                          alarm->message) < 2) {
                   free(alarm);
               } else {
                   status = pthread_create(&thread, NULL, alarm_thread, alarm);
                   if (status != 0)
                       err_abort(status, "Create alarm thread");
               }
           }
       }
     #+end_src
** Summany
   + In the fork version, each alarm has an independent address space, copied from the main program.
     That means we can put the seconds and message values into local variables, once the
     child has been created (when fork returns), the parent can change the values without
     affecting the alarm (as the child has its own copy).
   + In the threaded version, on the other hand, all threads share the same address space
     so we call malloc to create a new structure for each alarm, which is passed to the
     new thread.
   + In the fork version, 主程序负责free子程序产生的那些resources，要用到waitpid
   + In the threaded version, each alarm thread detaches itself so that the resources held
     by the thread will be returned immediately when it terminates.
   + In the fork version, 程序要做的主要事情(sleep & print)是放在一主函数里面实现的。小型项目还行，大的肯定不可以。
     而且系统不会允许你创建如此多的process的。
   + In the threaded version，(sleep & print)是单独有一个函数的，这样更好管理，在大型项目中更容易实现（每个事情给他
     一个函数routine嘛）

* Benefits of threading
  Some advantages of the multithreaded programming model follow:
  1) Exploitation of program parallelism on multiprocessor hardware
  2) More efficient exploitation of a program's natural concurrency, by allowing the
     program to perform computations while waiting for slow I/O operations to complete
  3) A modular programming model that clearly expresses relationships between independent "event" within
     the program.
  Detailed will be shown following.

** Parallelism
   + 说到并行，这必然是在多核cpu上，才能做到的啦 Amdahl定理:Speedup = 1/(（1-p） + p/n)
   + 由于p并不能精确计算，所以Amdahl其实只是存在理论意义，在实际情况中，你不仅仅要考虑你自己代码中的serialized region,你同时
     要考虑操作系统中的serialize region，因为在多核CPU中，每个核都有一个私有的data cache, the contents of those caches
     must be kept consistent with each other and with the data in memory. 
** Concurrency
   + threaded programming 允许在等待io操作的时候让process进行computational progress.这个对于C/S系统尤为重要，这也是为什么
     大多数C/S系统都使用这个thread的原因
   + 在一个thread等待冗长IO操作的时候，另外的thread可以利用这个时间进行操作，这个是"并发"性质的，也就是说不需要多核cpu的。
   + 有些系统支持asynchronous I/O 和thread起到的作用是一样的，但是asynchronous IO非常复杂，而且不是所有的Unix系统都支持这个
     feature（Unix普遍支持的是Nonblocking I/O, 即 allows the program to defer issuing an I/O operation until it
     can complete without blocking.
   + Synchronous I/O within multiple threads gives nearly all the advantages of asynchronous I/O.
   + Asynchronous I/O 比 thread 更轻量级， 但是也更麻烦，比如stdio这种synchronous 的function就不能利用了。
   + 除了Asynchronous IO, 我们还有一种方法叫做 Event，它比较适合simple application，因为它建立起来简单。但是因为它是sequential
     的，也就说，不支持并发，一个时期只能做一件事情，那么user interface很可能就会失去响应很久。
** Programming model
   + 即便你的代码永远不会在多核系统中运行，programming with thread依然是一个很好的主意。因为Writing with threads forces you to
     think about and plan for the synchronization requirements of your program.
   + If activities are designed as threads, each function must include explicit synchronization to enforce its
     dependencies.
* Costs of threading
** Computing overhead
   + 需要过多的时间进行"同步",比如 分开保护两个变量，但是这俩变量却经常一块被使用。
   + 想通过加入thread的方式来解决系统瓶颈的时候，经常会引入其他底层的瓶颈，而且更难以察觉。
   + compute-bound的thread很难被外来的event打断，所以多加几个compute-bound似乎更好的利用机器，其实因为引入了更多的synchronization和
     scheduling，反而性能可能会下降。
** Programming discipline
   + POSIX会保证大部分函数是thread-safe的，但是有些不是哦。这个要自己小心
   + 在一个process里面的thread是共享address space的。 If a thread writes to memory through an uninitialized pointer, it
     can wipe out another thread's stack, or heap memory being used by some other thread.
   + Good sequential code is not necessarily good threaded code.
** Harder to debug
   + When debugging asynchronous code, if one thread runs even slightly slower than another because it had to process a
     debugger trap, the problem you're trying to track down may not happen. You'll run a lot more of them when you use
     threads
   + It is difficult to track down a memory corruptor
   + Your most powerful and portable thread debugging tool is your mind, applied through the old fashinoed manual human-powered
     code review.
* To thread or not to thread
  The most obvious candidates for threaded coding are new applications that accomplish the following:
  + Perform extensive computation that can be parallelized into multiple threads, and which is intended
    to run on multiprocessor hardware
  + Perform substantial I/O which can be *overlapped* to improve throughtput - many threads can wait for different I/O requests
    at the same time. *Distributed server* applications are good candidates, since they may have work to do in response to multiple
    clients, and they must also be prepared for unsolicited I/O over relatively slow network connections.
* POSIX thread concepts
  POSIX is short for Portable Operating System System Interface for Unix
** Architectural overview
   + Three essential aspects of a thread system are execution context, scheduling, and synchronization.
   + With Pthreads, you creat an /execution context/ (thread) by calling pthread_create.
   + Creating a thread also /schedules/ the thread for execution, when you specify the "thread start function", the
     thread will run.
   + Pthreads allows you to specify /scheduling/ parameters either at the time you create the thread, or later on while the thread     
     is running.
   + A thread may return either from the thread start function, or when the thread calls pthread_exit.
   + The primary Pthreads /synchronization/ model uses *mutexes* for protection, and *condition* *variables* for communication. 
** Types and interfaces
   Following is the thread information in this book
   | type                | section | Description                              |
   |---------------------+---------+------------------------------------------|
   | pthread_t           |       2 | thread identifier                        |
   | pthread_mutex_t     |     3.2 | mutex                                    |
   | pthread_cond_t      |     3.3 | condition variables                      |
   | pthread_key_t       |     5.4 | "access key" for thread-specific data    |
   | pthread_attr_t      |   5.2.3 | thread attributes object                 |
   | pthread_mutexattr_t |   5.2.1 | mutex attributes object                  |
   | pthread_condattr_t  |   5.2.2 | condition variable attributes objects    |
   | pthread_once_t      |     5.1 | "one time initialization" control contex |
** Checking for errors
   + Following is the source code for thread_error.c, which checks for an error and waits for a thread.
     #+begin_src c
       #include <pthread.h>
       #include <stdio.h>
       #include <errno.h>
       
       int main(int argc, char *argv[])
       {
           pthread_t thread;
           int status;
       
           /*
            * Attempt to join with an uninitialized thread ID. On most
            * implementations, this will return an ESRCH error code. If
            * the local (and uninitialized) pthread_t happens to be a valid
            * thread ID, it is almost certainly that of the initial thread,
            * which is running main(). In that case, your Pthreads
            * implementation may either return EDEADLK (self-deadlock),
            * or it may hang. If it hangs, quit and try again.
            */
           status = pthread_join(thread, NULL);
           if (status != 0)
               fprintf(stderr, "error %d: %s\n", status, strerror(status));
           return status;
       }
     #+end_src
   + Following code is the source code for errors.h, in which err_abort detects a standard Pthreads error,
     and errno_abort is used when a value of -1 means that errno contains an error code.
     #+begin_src c
       #ifndef __errors_h
       #define __errors_h
       
       #include <unistd.h>
       #include <errno.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <string.h>
       
       /*
        * Define a macro that can be used for diagnostic output from
        * examples. When compiled -DDEBUG, it results in calling printf
        * with the specified argument list. When DEBUG is not defined, it
        * expands to nothing.
        */
       #ifdef DEBUG
       # define DPRINTF(arg) printf arg
       #else
       # define DPRINTF(arg)
       #endif
       
       /*
        * NOTE: the "do {" ... "} while (0);" bracketing around the macros
        * allows the err_abort and errno_abort macros to be used as if they
        * were function calls, even in contexts where a trailing ";" would
        * generate a null statement. For example,
        *
        *      if (status != 0)
        *          err_abort (status, "message");
        *      else
        *          return status;
        *
        * will not compile if err_abort is a macro ending with "}", because
        * C does not expect a ";" to follow the "}". Because C does expect
        * a ";" following the ")" in the do...while construct, err_abort and
        * errno_abort can be used as if they were function calls.
        */
       #define err_abort(code,text) do { \
           fprintf (stderr, "%s at \"%s\":%d: %s\n", \
               text, __FILE__, __LINE__, strerror (code)); \
           abort (); \
           } while (0)
       #define errno_abort(text) do { \
           fprintf (stderr, "%s at \"%s\":%d: %s\n", \
               text, __FILE__, __LINE__, strerror (errno)); \
           abort (); \
           } while (0)
       
       #endif 
        
     #+end_src

